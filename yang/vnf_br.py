# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_vnf_vnf_br__vnf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /vnf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The VNF-BR target SUT VNF.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__version','__author','__description',)

  _yang_name = 'vnf'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__author = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="author", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['vnf']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /vnf/id (string)

    YANG Description: The VNF unique identifier.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /vnf/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The VNF unique identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /vnf/name (string)

    YANG Description: The VNF name.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /vnf/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The VNF name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /vnf/version (string)

    YANG Description: The VNF version.
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /vnf/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The VNF version.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_author(self):
    """
    Getter method for author, mapped from YANG variable /vnf/author (string)

    YANG Description: The author of the VNF.
    """
    return self.__author
      
  def _set_author(self, v, load=False):
    """
    Setter method for author, mapped from YANG variable /vnf/author (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_author is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_author() directly.

    YANG Description: The author of the VNF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="author", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """author must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="author", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__author = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_author(self):
    self.__author = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="author", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /vnf/description (string)

    YANG Description: The description of the VNF.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /vnf/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: The description of the VNF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  version = __builtin__.property(_get_version, _set_version)
  author = __builtin__.property(_get_author, _set_author)
  description = __builtin__.property(_get_description, _set_description)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('version', version), ('author', author), ('description', description), ])


class yc_parameters_vnf_br__environment_orchestrator_parameters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /environment/orchestrator/parameters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of orchestrator
input parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__input','__value',)

  _yang_name = 'parameters'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__input = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['environment', 'orchestrator', 'parameters']

  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /environment/orchestrator/parameters/input (string)

    YANG Description: The name of the parameter
    """
    return self.__input
      
  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /environment/orchestrator/parameters/input (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.

    YANG Description: The name of the parameter
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /environment/orchestrator/parameters/value (string)

    YANG Description: The value of the parameter
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /environment/orchestrator/parameters/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: The value of the parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  input = __builtin__.property(_get_input, _set_input)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('input', input), ('value', value), ])


class yc_orchestrator_vnf_br__environment_orchestrator(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /environment/orchestrator. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The specification of the orchestration platform
settings of a VNF-BR.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__type','__description','__parameters',)

  _yang_name = 'orchestrator'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__parameters = YANGDynClass(base=YANGListType("input",yc_parameters_vnf_br__environment_orchestrator_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['environment', 'orchestrator']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /environment/orchestrator/name (string)

    YANG Description: Name of the orchestrator
platform.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /environment/orchestrator/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the orchestrator
platform.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /environment/orchestrator/type (string)

    YANG Description: The type of the orchestrator
platform.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /environment/orchestrator/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of the orchestrator
platform.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /environment/orchestrator/description (string)

    YANG Description: The description of the
orchestrator platform.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /environment/orchestrator/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: The description of the
orchestrator platform.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_parameters(self):
    """
    Getter method for parameters, mapped from YANG variable /environment/orchestrator/parameters (list)

    YANG Description: List of orchestrator
input parameters.
    """
    return self.__parameters
      
  def _set_parameters(self, v, load=False):
    """
    Setter method for parameters, mapped from YANG variable /environment/orchestrator/parameters (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameters() directly.

    YANG Description: List of orchestrator
input parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("input",yc_parameters_vnf_br__environment_orchestrator_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameters must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("input",yc_parameters_vnf_br__environment_orchestrator_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__parameters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameters(self):
    self.__parameters = YANGDynClass(base=YANGListType("input",yc_parameters_vnf_br__environment_orchestrator_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  description = __builtin__.property(_get_description, _set_description)
  parameters = __builtin__.property(_get_parameters, _set_parameters)


  _pyangbind_elements = OrderedDict([('name', name), ('type', type), ('description', description), ('parameters', parameters), ])


class yc_environment_vnf_br__environment(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /environment. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The environment settings of a VNF-BR.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__description','__deploy','__orchestrator',)

  _yang_name = 'environment'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__deploy = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="deploy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='boolean', is_config=True)
    self.__orchestrator = YANGDynClass(base=yc_orchestrator_vnf_br__environment_orchestrator, is_container='container', yang_name="orchestrator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['environment']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /environment/name (string)

    YANG Description: The evironment name
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /environment/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The evironment name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /environment/description (string)

    YANG Description: A description
of the environment
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /environment/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: A description
of the environment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_deploy(self):
    """
    Getter method for deploy, mapped from YANG variable /environment/deploy (boolean)

    YANG Description: Defines if (True) the environment enables
the automated deployment by an orchestrator platform.
    """
    return self.__deploy
      
  def _set_deploy(self, v, load=False):
    """
    Setter method for deploy, mapped from YANG variable /environment/deploy (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_deploy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_deploy() directly.

    YANG Description: Defines if (True) the environment enables
the automated deployment by an orchestrator platform.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="deploy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """deploy must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="deploy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='boolean', is_config=True)""",
        })

    self.__deploy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_deploy(self):
    self.__deploy = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="deploy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='boolean', is_config=True)


  def _get_orchestrator(self):
    """
    Getter method for orchestrator, mapped from YANG variable /environment/orchestrator (container)

    YANG Description: The specification of the orchestration platform
settings of a VNF-BR.
    """
    return self.__orchestrator
      
  def _set_orchestrator(self, v, load=False):
    """
    Setter method for orchestrator, mapped from YANG variable /environment/orchestrator (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_orchestrator is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_orchestrator() directly.

    YANG Description: The specification of the orchestration platform
settings of a VNF-BR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_orchestrator_vnf_br__environment_orchestrator, is_container='container', yang_name="orchestrator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """orchestrator must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_orchestrator_vnf_br__environment_orchestrator, is_container='container', yang_name="orchestrator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__orchestrator = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_orchestrator(self):
    self.__orchestrator = YANGDynClass(base=yc_orchestrator_vnf_br__environment_orchestrator, is_container='container', yang_name="orchestrator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  deploy = __builtin__.property(_get_deploy, _set_deploy)
  orchestrator = __builtin__.property(_get_orchestrator, _set_orchestrator)


  _pyangbind_elements = OrderedDict([('name', name), ('description', description), ('deploy', deploy), ('orchestrator', orchestrator), ])


class yc_variables_vnf_br__inputs_variables(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/variables. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of
input variables.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__path','__type','__class_','__values',)

  _yang_name = 'variables'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__path = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__class_ = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__values = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="values", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'variables']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /inputs/variables/name (string)

    YANG Description: The name of the variable.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /inputs/variables/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the variable.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_path(self):
    """
    Getter method for path, mapped from YANG variable /inputs/variables/path (string)

    YANG Description: The VNF-BD YANG path of the
variable.
    """
    return self.__path
      
  def _set_path(self, v, load=False):
    """
    Setter method for path, mapped from YANG variable /inputs/variables/path (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path() directly.

    YANG Description: The VNF-BD YANG path of the
variable.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """path must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_path(self):
    self.__path = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /inputs/variables/type (string)

    YANG Description: The type of the
variable values.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /inputs/variables/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of the
variable values.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_class_(self):
    """
    Getter method for class_, mapped from YANG variable /inputs/variables/class (string)

    YANG Description: The class of the
variable (one of resource, stimulus,
configuration).
    """
    return self.__class_
      
  def _set_class_(self, v, load=False):
    """
    Setter method for class_, mapped from YANG variable /inputs/variables/class (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_class_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_class_() directly.

    YANG Description: The class of the
variable (one of resource, stimulus,
configuration).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """class_ must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__class_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_class_(self):
    self.__class_ = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_values(self):
    """
    Getter method for values, mapped from YANG variable /inputs/variables/values (string)

    YANG Description: The list of values
of the variable.
    """
    return self.__values
      
  def _set_values(self, v, load=False):
    """
    Setter method for values, mapped from YANG variable /inputs/variables/values (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_values is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_values() directly.

    YANG Description: The list of values
of the variable.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="values", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """values must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="values", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__values = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_values(self):
    self.__values = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="values", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  path = __builtin__.property(_get_path, _set_path)
  type = __builtin__.property(_get_type, _set_type)
  class_ = __builtin__.property(_get_class_, _set_class_)
  values = __builtin__.property(_get_values, _set_values)


  _pyangbind_elements = OrderedDict([('name', name), ('path', path), ('type', type), ('class_', class_), ('values', values), ])


class yc_experiments_vnf_br__inputs_vnfbd_experiments(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd/experiments. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines the number of trials and tests
the VNF-BD must execute.
  """
  __slots__ = ('_path_helper', '_extmethods', '__trials','__tests',)

  _yang_name = 'experiments'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__trials = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="trials", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__tests = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="tests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd', 'experiments']

  def _get_trials(self):
    """
    Getter method for trials, mapped from YANG variable /inputs/vnfbd/experiments/trials (uint32)

    YANG Description: Number of trials.
A trial is a single process or iteration
to obtain VNF performance metrics from
benchmarking the VNF-BD proceedings.
    """
    return self.__trials
      
  def _set_trials(self, v, load=False):
    """
    Setter method for trials, mapped from YANG variable /inputs/vnfbd/experiments/trials (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trials is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trials() directly.

    YANG Description: Number of trials.
A trial is a single process or iteration
to obtain VNF performance metrics from
benchmarking the VNF-BD proceedings.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="trials", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trials must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="trials", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__trials = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trials(self):
    self.__trials = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="trials", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_tests(self):
    """
    Getter method for tests, mapped from YANG variable /inputs/vnfbd/experiments/tests (uint32)

    YANG Description: Number of tests.
Each test defines unique structural
and functional parameters (e.g., configurations,
resource assignment) for benchmarked components
to perform one or multiple Trials.
Each Test must be executed following a
particular scenario.
    """
    return self.__tests
      
  def _set_tests(self, v, load=False):
    """
    Setter method for tests, mapped from YANG variable /inputs/vnfbd/experiments/tests (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tests is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tests() directly.

    YANG Description: Number of tests.
Each test defines unique structural
and functional parameters (e.g., configurations,
resource assignment) for benchmarked components
to perform one or multiple Trials.
Each Test must be executed following a
particular scenario.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="tests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tests must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="tests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__tests = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tests(self):
    self.__tests = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="tests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)

  trials = __builtin__.property(_get_trials, _set_trials)
  tests = __builtin__.property(_get_tests, _set_tests)


  _pyangbind_elements = OrderedDict([('trials', trials), ('tests', tests), ])


class yc_cpu_vnf_br__inputs_vnfbd_scenario_nodes_resources_cpu(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd/scenario/nodes/resources/cpu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The node CPU resources that must
be allocated for a benchmarking Test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vcpus','__cpu_bw','__pinning',)

  _yang_name = 'cpu'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__vcpus = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vcpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__cpu_bw = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpu_bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__pinning = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pinning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd', 'scenario', 'nodes', 'resources', 'cpu']

  def _get_vcpus(self):
    """
    Getter method for vcpus, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources/cpu/vcpus (uint32)

    YANG Description: The number of cores to be allocated
for a node.
    """
    return self.__vcpus
      
  def _set_vcpus(self, v, load=False):
    """
    Setter method for vcpus, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources/cpu/vcpus (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vcpus is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vcpus() directly.

    YANG Description: The number of cores to be allocated
for a node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vcpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vcpus must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vcpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__vcpus = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vcpus(self):
    self.__vcpus = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vcpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_cpu_bw(self):
    """
    Getter method for cpu_bw, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources/cpu/cpu_bw (string)

    YANG Description: The CPU bandwidth (CFS limit in 0.01-1.0)
    """
    return self.__cpu_bw
      
  def _set_cpu_bw(self, v, load=False):
    """
    Setter method for cpu_bw, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources/cpu/cpu_bw (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_bw is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_bw() directly.

    YANG Description: The CPU bandwidth (CFS limit in 0.01-1.0)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cpu_bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_bw must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpu_bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__cpu_bw = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_bw(self):
    self.__cpu_bw = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpu_bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_pinning(self):
    """
    Getter method for pinning, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources/cpu/pinning (string)

    YANG Description: The list of CPU cores, separated by comma,
that a node must be pinned to.
    """
    return self.__pinning
      
  def _set_pinning(self, v, load=False):
    """
    Setter method for pinning, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources/cpu/pinning (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pinning is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pinning() directly.

    YANG Description: The list of CPU cores, separated by comma,
that a node must be pinned to.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="pinning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pinning must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pinning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__pinning = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pinning(self):
    self.__pinning = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pinning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  vcpus = __builtin__.property(_get_vcpus, _set_vcpus)
  cpu_bw = __builtin__.property(_get_cpu_bw, _set_cpu_bw)
  pinning = __builtin__.property(_get_pinning, _set_pinning)


  _pyangbind_elements = OrderedDict([('vcpus', vcpus), ('cpu_bw', cpu_bw), ('pinning', pinning), ])


class yc_memory_vnf_br__inputs_vnfbd_scenario_nodes_resources_memory(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd/scenario/nodes/resources/memory. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The node memory resources
that must be allocated for a benchmarking
Test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__size','__unit',)

  _yang_name = 'memory'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__unit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd', 'scenario', 'nodes', 'resources', 'memory']

  def _get_size(self):
    """
    Getter method for size, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources/memory/size (uint32)

    YANG Description: The memory allocation size.
    """
    return self.__size
      
  def _set_size(self, v, load=False):
    """
    Setter method for size, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources/memory/size (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_size() directly.

    YANG Description: The memory allocation size.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """size must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_size(self):
    self.__size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_unit(self):
    """
    Getter method for unit, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources/memory/unit (string)

    YANG Description: The memory unit.
    """
    return self.__unit
      
  def _set_unit(self, v, load=False):
    """
    Setter method for unit, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources/memory/unit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unit() directly.

    YANG Description: The memory unit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__unit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unit(self):
    self.__unit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  size = __builtin__.property(_get_size, _set_size)
  unit = __builtin__.property(_get_unit, _set_unit)


  _pyangbind_elements = OrderedDict([('size', size), ('unit', unit), ])


class yc_storage_vnf_br__inputs_vnfbd_scenario_nodes_resources_storage(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd/scenario/nodes/resources/storage. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The node storage resources
that must be allocated for a benchmarking Test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__size','__unit','__volumes',)

  _yang_name = 'storage'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__unit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__volumes = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="volumes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd', 'scenario', 'nodes', 'resources', 'storage']

  def _get_size(self):
    """
    Getter method for size, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources/storage/size (uint32)

    YANG Description: The storage allocation size.
    """
    return self.__size
      
  def _set_size(self, v, load=False):
    """
    Setter method for size, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources/storage/size (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_size() directly.

    YANG Description: The storage allocation size.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """size must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_size(self):
    self.__size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_unit(self):
    """
    Getter method for unit, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources/storage/unit (string)

    YANG Description: The storage unit.
    """
    return self.__unit
      
  def _set_unit(self, v, load=False):
    """
    Setter method for unit, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources/storage/unit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unit() directly.

    YANG Description: The storage unit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__unit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unit(self):
    self.__unit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_volumes(self):
    """
    Getter method for volumes, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources/storage/volumes (string)

    YANG Description: Volumes to be allocated by
a node storage.
A volume defines a mapping of an outside storage
partition inside the node storage system.
Volumes must be separated by comma and be defined
using a colon to separate the node internal and external
references of storage system paths.
    """
    return self.__volumes
      
  def _set_volumes(self, v, load=False):
    """
    Setter method for volumes, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources/storage/volumes (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_volumes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_volumes() directly.

    YANG Description: Volumes to be allocated by
a node storage.
A volume defines a mapping of an outside storage
partition inside the node storage system.
Volumes must be separated by comma and be defined
using a colon to separate the node internal and external
references of storage system paths.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="volumes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """volumes must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="volumes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__volumes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_volumes(self):
    self.__volumes = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="volumes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  size = __builtin__.property(_get_size, _set_size)
  unit = __builtin__.property(_get_unit, _set_unit)
  volumes = __builtin__.property(_get_volumes, _set_volumes)


  _pyangbind_elements = OrderedDict([('size', size), ('unit', unit), ('volumes', volumes), ])


class yc_resources_vnf_br__inputs_vnfbd_scenario_nodes_resources(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd/scenario/nodes/resources. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The set of resources that must be allocated
for a node in a benchmarking Test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__cpu','__memory','__storage',)

  _yang_name = 'resources'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__cpu = YANGDynClass(base=yc_cpu_vnf_br__inputs_vnfbd_scenario_nodes_resources_cpu, is_container='container', yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    self.__memory = YANGDynClass(base=yc_memory_vnf_br__inputs_vnfbd_scenario_nodes_resources_memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    self.__storage = YANGDynClass(base=yc_storage_vnf_br__inputs_vnfbd_scenario_nodes_resources_storage, is_container='container', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd', 'scenario', 'nodes', 'resources']

  def _get_cpu(self):
    """
    Getter method for cpu, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources/cpu (container)

    YANG Description: The node CPU resources that must
be allocated for a benchmarking Test.
    """
    return self.__cpu
      
  def _set_cpu(self, v, load=False):
    """
    Setter method for cpu, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources/cpu (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu() directly.

    YANG Description: The node CPU resources that must
be allocated for a benchmarking Test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_cpu_vnf_br__inputs_vnfbd_scenario_nodes_resources_cpu, is_container='container', yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_cpu_vnf_br__inputs_vnfbd_scenario_nodes_resources_cpu, is_container='container', yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__cpu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu(self):
    self.__cpu = YANGDynClass(base=yc_cpu_vnf_br__inputs_vnfbd_scenario_nodes_resources_cpu, is_container='container', yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)


  def _get_memory(self):
    """
    Getter method for memory, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources/memory (container)

    YANG Description: The node memory resources
that must be allocated for a benchmarking
Test.
    """
    return self.__memory
      
  def _set_memory(self, v, load=False):
    """
    Setter method for memory, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources/memory (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory() directly.

    YANG Description: The node memory resources
that must be allocated for a benchmarking
Test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_memory_vnf_br__inputs_vnfbd_scenario_nodes_resources_memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """memory must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_memory_vnf_br__inputs_vnfbd_scenario_nodes_resources_memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__memory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_memory(self):
    self.__memory = YANGDynClass(base=yc_memory_vnf_br__inputs_vnfbd_scenario_nodes_resources_memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)


  def _get_storage(self):
    """
    Getter method for storage, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources/storage (container)

    YANG Description: The node storage resources
that must be allocated for a benchmarking Test.
    """
    return self.__storage
      
  def _set_storage(self, v, load=False):
    """
    Setter method for storage, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources/storage (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_storage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_storage() directly.

    YANG Description: The node storage resources
that must be allocated for a benchmarking Test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_storage_vnf_br__inputs_vnfbd_scenario_nodes_resources_storage, is_container='container', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """storage must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_storage_vnf_br__inputs_vnfbd_scenario_nodes_resources_storage, is_container='container', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__storage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_storage(self):
    self.__storage = YANGDynClass(base=yc_storage_vnf_br__inputs_vnfbd_scenario_nodes_resources_storage, is_container='container', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)

  cpu = __builtin__.property(_get_cpu, _set_cpu)
  memory = __builtin__.property(_get_memory, _set_memory)
  storage = __builtin__.property(_get_storage, _set_storage)


  _pyangbind_elements = OrderedDict([('cpu', cpu), ('memory', memory), ('storage', storage), ])


class yc_connection_points_vnf_br__inputs_vnfbd_scenario_nodes_connection_points(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd/scenario/nodes/connection_points. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of connection points of a node.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__interface','__type','__address',)

  _yang_name = 'connection_points'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd', 'scenario', 'nodes', 'connection_points']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /inputs/vnfbd/scenario/nodes/connection_points/id (string)

    YANG Description: The connection-point
unique identifier
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /inputs/vnfbd/scenario/nodes/connection_points/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The connection-point
unique identifier
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /inputs/vnfbd/scenario/nodes/connection_points/interface (string)

    YANG Description: The name of the node interface
associated with the connection-point.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /inputs/vnfbd/scenario/nodes/connection_points/interface (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: The name of the node interface
associated with the connection-point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /inputs/vnfbd/scenario/nodes/connection_points/type (string)

    YANG Description: The type of the network the
connection-point interface is attached to.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /inputs/vnfbd/scenario/nodes/connection_points/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of the network the
connection-point interface is attached to.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /inputs/vnfbd/scenario/nodes/connection_points/address (string)

    YANG Description: The Network address of the
connection-point. It can be specified as a
Ethernet MAC address, a IPv4 address or an IPv6 address.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /inputs/vnfbd/scenario/nodes/connection_points/address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: The Network address of the
connection-point. It can be specified as a
Ethernet MAC address, a IPv4 address or an IPv6 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  interface = __builtin__.property(_get_interface, _set_interface)
  type = __builtin__.property(_get_type, _set_type)
  address = __builtin__.property(_get_address, _set_address)


  _pyangbind_elements = OrderedDict([('id', id), ('interface', interface), ('type', type), ('address', address), ])


class yc_relationships_vnf_br__inputs_vnfbd_scenario_nodes_relationships(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd/scenario/nodes/relationships. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Relationship of a node with the other
scenario components.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__type','__target',)

  _yang_name = 'relationships'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__target = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd', 'scenario', 'nodes', 'relationships']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /inputs/vnfbd/scenario/nodes/relationships/name (string)

    YANG Description: Name of the relationship.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /inputs/vnfbd/scenario/nodes/relationships/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the relationship.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /inputs/vnfbd/scenario/nodes/relationships/type (string)

    YANG Description: Type of the relationship.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /inputs/vnfbd/scenario/nodes/relationships/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the relationship.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_target(self):
    """
    Getter method for target, mapped from YANG variable /inputs/vnfbd/scenario/nodes/relationships/target (string)

    YANG Description: Target of the relationship.
    """
    return self.__target
      
  def _set_target(self, v, load=False):
    """
    Setter method for target, mapped from YANG variable /inputs/vnfbd/scenario/nodes/relationships/target (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target() directly.

    YANG Description: Target of the relationship.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__target = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target(self):
    self.__target = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  target = __builtin__.property(_get_target, _set_target)


  _pyangbind_elements = OrderedDict([('name', name), ('type', type), ('target', target), ])


class yc_parameters_vnf_br__inputs_vnfbd_scenario_nodes_lifecycle_parameters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd/scenario/nodes/lifecycle/parameters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of parameters to be
applied to the node workflow.
  """
  __slots__ = ('_path_helper', '_extmethods', '__input','__value',)

  _yang_name = 'parameters'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__input = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd', 'scenario', 'nodes', 'lifecycle', 'parameters']

  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /inputs/vnfbd/scenario/nodes/lifecycle/parameters/input (string)

    YANG Description: The name of the parameter.
    """
    return self.__input
      
  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /inputs/vnfbd/scenario/nodes/lifecycle/parameters/input (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.

    YANG Description: The name of the parameter.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /inputs/vnfbd/scenario/nodes/lifecycle/parameters/value (string)

    YANG Description: The value of the parameter
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /inputs/vnfbd/scenario/nodes/lifecycle/parameters/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: The value of the parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  input = __builtin__.property(_get_input, _set_input)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('input', input), ('value', value), ])


class yc_lifecycle_vnf_br__inputs_vnfbd_scenario_nodes_lifecycle(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd/scenario/nodes/lifecycle. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The life cycle workflows to be
applied to this node.
  """
  __slots__ = ('_path_helper', '_extmethods', '__workflow','__name','__parameters','__implementation',)

  _yang_name = 'lifecycle'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__workflow = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'create': {}, 'configure': {}, 'start': {}, 'stop': {}, 'delete': {}, 'custom': {}},), is_leaf=True, yang_name="workflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='workflows', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__parameters = YANGDynClass(base=YANGListType("input",yc_parameters_vnf_br__inputs_vnfbd_scenario_nodes_lifecycle_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    self.__implementation = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="implementation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd', 'scenario', 'nodes', 'lifecycle']

  def _get_workflow(self):
    """
    Getter method for workflow, mapped from YANG variable /inputs/vnfbd/scenario/nodes/lifecycle/workflow (workflows)

    YANG Description: The type of the Workflow.
    """
    return self.__workflow
      
  def _set_workflow(self, v, load=False):
    """
    Setter method for workflow, mapped from YANG variable /inputs/vnfbd/scenario/nodes/lifecycle/workflow (workflows)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_workflow is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_workflow() directly.

    YANG Description: The type of the Workflow.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'create': {}, 'configure': {}, 'start': {}, 'stop': {}, 'delete': {}, 'custom': {}},), is_leaf=True, yang_name="workflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='workflows', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """workflow must be of a type compatible with workflows""",
          'defined-type': "vnf-br:workflows",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'create': {}, 'configure': {}, 'start': {}, 'stop': {}, 'delete': {}, 'custom': {}},), is_leaf=True, yang_name="workflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='workflows', is_config=True)""",
        })

    self.__workflow = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_workflow(self):
    self.__workflow = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'create': {}, 'configure': {}, 'start': {}, 'stop': {}, 'delete': {}, 'custom': {}},), is_leaf=True, yang_name="workflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='workflows', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /inputs/vnfbd/scenario/nodes/lifecycle/name (string)

    YANG Description: The workflow name.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /inputs/vnfbd/scenario/nodes/lifecycle/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The workflow name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_parameters(self):
    """
    Getter method for parameters, mapped from YANG variable /inputs/vnfbd/scenario/nodes/lifecycle/parameters (list)

    YANG Description: The list of parameters to be
applied to the node workflow.
    """
    return self.__parameters
      
  def _set_parameters(self, v, load=False):
    """
    Setter method for parameters, mapped from YANG variable /inputs/vnfbd/scenario/nodes/lifecycle/parameters (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameters() directly.

    YANG Description: The list of parameters to be
applied to the node workflow.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("input",yc_parameters_vnf_br__inputs_vnfbd_scenario_nodes_lifecycle_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameters must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("input",yc_parameters_vnf_br__inputs_vnfbd_scenario_nodes_lifecycle_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__parameters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameters(self):
    self.__parameters = YANGDynClass(base=YANGListType("input",yc_parameters_vnf_br__inputs_vnfbd_scenario_nodes_lifecycle_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)


  def _get_implementation(self):
    """
    Getter method for implementation, mapped from YANG variable /inputs/vnfbd/scenario/nodes/lifecycle/implementation (string)

    YANG Description: The workflow implementation.
    """
    return self.__implementation
      
  def _set_implementation(self, v, load=False):
    """
    Setter method for implementation, mapped from YANG variable /inputs/vnfbd/scenario/nodes/lifecycle/implementation (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_implementation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_implementation() directly.

    YANG Description: The workflow implementation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="implementation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """implementation must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="implementation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__implementation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_implementation(self):
    self.__implementation = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="implementation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  workflow = __builtin__.property(_get_workflow, _set_workflow)
  name = __builtin__.property(_get_name, _set_name)
  parameters = __builtin__.property(_get_parameters, _set_parameters)
  implementation = __builtin__.property(_get_implementation, _set_implementation)


  _pyangbind_elements = OrderedDict([('workflow', workflow), ('name', name), ('parameters', parameters), ('implementation', implementation), ])


class yc_nodes_vnf_br__inputs_vnfbd_scenario_nodes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd/scenario/nodes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of nodes that must be
instantiated in a scenario in order to enable
a benchmarking Test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__type','__image','__format','__role','__resources','__connection_points','__relationships','__lifecycle',)

  _yang_name = 'nodes'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__image = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__format = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__role = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__resources = YANGDynClass(base=yc_resources_vnf_br__inputs_vnfbd_scenario_nodes_resources, is_container='container', yang_name="resources", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    self.__connection_points = YANGDynClass(base=YANGListType("id",yc_connection_points_vnf_br__inputs_vnfbd_scenario_nodes_connection_points, yang_name="connection_points", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    self.__relationships = YANGDynClass(base=YANGListType("name",yc_relationships_vnf_br__inputs_vnfbd_scenario_nodes_relationships, yang_name="relationships", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="relationships", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    self.__lifecycle = YANGDynClass(base=YANGListType("workflow",yc_lifecycle_vnf_br__inputs_vnfbd_scenario_nodes_lifecycle, yang_name="lifecycle", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='workflow', extensions=None), is_container='list', yang_name="lifecycle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd', 'scenario', 'nodes']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /inputs/vnfbd/scenario/nodes/id (string)

    YANG Description: The unique identifier of a node
in a scenario.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /inputs/vnfbd/scenario/nodes/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The unique identifier of a node
in a scenario.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /inputs/vnfbd/scenario/nodes/type (string)

    YANG Description: The type of a node.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /inputs/vnfbd/scenario/nodes/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of a node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_image(self):
    """
    Getter method for image, mapped from YANG variable /inputs/vnfbd/scenario/nodes/image (string)

    YANG Description: The name of the image to be used to instantiate
a node.
    """
    return self.__image
      
  def _set_image(self, v, load=False):
    """
    Setter method for image, mapped from YANG variable /inputs/vnfbd/scenario/nodes/image (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_image is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_image() directly.

    YANG Description: The name of the image to be used to instantiate
a node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """image must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__image = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_image(self):
    self.__image = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_format(self):
    """
    Getter method for format, mapped from YANG variable /inputs/vnfbd/scenario/nodes/format (string)

    YANG Description: The node format (e.g., container, process, VM).
    """
    return self.__format
      
  def _set_format(self, v, load=False):
    """
    Setter method for format, mapped from YANG variable /inputs/vnfbd/scenario/nodes/format (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_format is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_format() directly.

    YANG Description: The node format (e.g., container, process, VM).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """format must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__format = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_format(self):
    self.__format = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_role(self):
    """
    Getter method for role, mapped from YANG variable /inputs/vnfbd/scenario/nodes/role (string)

    YANG Description: The role of the node in the Test scenario.
The role must be one of: manager, agent, monitor, sut.
    """
    return self.__role
      
  def _set_role(self, v, load=False):
    """
    Setter method for role, mapped from YANG variable /inputs/vnfbd/scenario/nodes/role (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_role is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_role() directly.

    YANG Description: The role of the node in the Test scenario.
The role must be one of: manager, agent, monitor, sut.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """role must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__role = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_role(self):
    self.__role = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_resources(self):
    """
    Getter method for resources, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources (container)

    YANG Description: The set of resources that must be allocated
for a node in a benchmarking Test.
    """
    return self.__resources
      
  def _set_resources(self, v, load=False):
    """
    Setter method for resources, mapped from YANG variable /inputs/vnfbd/scenario/nodes/resources (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_resources is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_resources() directly.

    YANG Description: The set of resources that must be allocated
for a node in a benchmarking Test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_resources_vnf_br__inputs_vnfbd_scenario_nodes_resources, is_container='container', yang_name="resources", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """resources must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_resources_vnf_br__inputs_vnfbd_scenario_nodes_resources, is_container='container', yang_name="resources", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__resources = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_resources(self):
    self.__resources = YANGDynClass(base=yc_resources_vnf_br__inputs_vnfbd_scenario_nodes_resources, is_container='container', yang_name="resources", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)


  def _get_connection_points(self):
    """
    Getter method for connection_points, mapped from YANG variable /inputs/vnfbd/scenario/nodes/connection_points (list)

    YANG Description: The list of connection points of a node.
    """
    return self.__connection_points
      
  def _set_connection_points(self, v, load=False):
    """
    Setter method for connection_points, mapped from YANG variable /inputs/vnfbd/scenario/nodes/connection_points (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_points is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_points() directly.

    YANG Description: The list of connection points of a node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_connection_points_vnf_br__inputs_vnfbd_scenario_nodes_connection_points, yang_name="connection_points", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_points must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_connection_points_vnf_br__inputs_vnfbd_scenario_nodes_connection_points, yang_name="connection_points", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__connection_points = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_points(self):
    self.__connection_points = YANGDynClass(base=YANGListType("id",yc_connection_points_vnf_br__inputs_vnfbd_scenario_nodes_connection_points, yang_name="connection_points", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)


  def _get_relationships(self):
    """
    Getter method for relationships, mapped from YANG variable /inputs/vnfbd/scenario/nodes/relationships (list)

    YANG Description: Relationship of a node with the other
scenario components.
    """
    return self.__relationships
      
  def _set_relationships(self, v, load=False):
    """
    Setter method for relationships, mapped from YANG variable /inputs/vnfbd/scenario/nodes/relationships (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relationships is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relationships() directly.

    YANG Description: Relationship of a node with the other
scenario components.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_relationships_vnf_br__inputs_vnfbd_scenario_nodes_relationships, yang_name="relationships", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="relationships", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """relationships must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_relationships_vnf_br__inputs_vnfbd_scenario_nodes_relationships, yang_name="relationships", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="relationships", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__relationships = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_relationships(self):
    self.__relationships = YANGDynClass(base=YANGListType("name",yc_relationships_vnf_br__inputs_vnfbd_scenario_nodes_relationships, yang_name="relationships", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="relationships", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)


  def _get_lifecycle(self):
    """
    Getter method for lifecycle, mapped from YANG variable /inputs/vnfbd/scenario/nodes/lifecycle (list)

    YANG Description: The life cycle workflows to be
applied to this node.
    """
    return self.__lifecycle
      
  def _set_lifecycle(self, v, load=False):
    """
    Setter method for lifecycle, mapped from YANG variable /inputs/vnfbd/scenario/nodes/lifecycle (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lifecycle is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lifecycle() directly.

    YANG Description: The life cycle workflows to be
applied to this node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("workflow",yc_lifecycle_vnf_br__inputs_vnfbd_scenario_nodes_lifecycle, yang_name="lifecycle", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='workflow', extensions=None), is_container='list', yang_name="lifecycle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lifecycle must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("workflow",yc_lifecycle_vnf_br__inputs_vnfbd_scenario_nodes_lifecycle, yang_name="lifecycle", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='workflow', extensions=None), is_container='list', yang_name="lifecycle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__lifecycle = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lifecycle(self):
    self.__lifecycle = YANGDynClass(base=YANGListType("workflow",yc_lifecycle_vnf_br__inputs_vnfbd_scenario_nodes_lifecycle, yang_name="lifecycle", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='workflow', extensions=None), is_container='list', yang_name="lifecycle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  type = __builtin__.property(_get_type, _set_type)
  image = __builtin__.property(_get_image, _set_image)
  format = __builtin__.property(_get_format, _set_format)
  role = __builtin__.property(_get_role, _set_role)
  resources = __builtin__.property(_get_resources, _set_resources)
  connection_points = __builtin__.property(_get_connection_points, _set_connection_points)
  relationships = __builtin__.property(_get_relationships, _set_relationships)
  lifecycle = __builtin__.property(_get_lifecycle, _set_lifecycle)


  _pyangbind_elements = OrderedDict([('id', id), ('type', type), ('image', image), ('format', format), ('role', role), ('resources', resources), ('connection_points', connection_points), ('relationships', relationships), ('lifecycle', lifecycle), ])


class yc_links_vnf_br__inputs_vnfbd_scenario_links(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd/scenario/links. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of links among nodes that must be
instantiated in a scenario in order to enable
a benchmarking Test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__type','__network','__connection_points',)

  _yang_name = 'links'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__network = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__connection_points = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd', 'scenario', 'links']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /inputs/vnfbd/scenario/links/id (string)

    YANG Description: The link unique identifier.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /inputs/vnfbd/scenario/links/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The link unique identifier.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /inputs/vnfbd/scenario/links/name (string)

    YANG Description: The name of the link.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /inputs/vnfbd/scenario/links/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the link.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /inputs/vnfbd/scenario/links/type (string)

    YANG Description: The type of the link.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /inputs/vnfbd/scenario/links/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of the link.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_network(self):
    """
    Getter method for network, mapped from YANG variable /inputs/vnfbd/scenario/links/network (string)

    YANG Description: The network the link belongs to.
    """
    return self.__network
      
  def _set_network(self, v, load=False):
    """
    Setter method for network, mapped from YANG variable /inputs/vnfbd/scenario/links/network (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network() directly.

    YANG Description: The network the link belongs to.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network(self):
    self.__network = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_connection_points(self):
    """
    Getter method for connection_points, mapped from YANG variable /inputs/vnfbd/scenario/links/connection_points (leafref)

    YANG Description: Reference to the connection points of nodes
the link is adjacent.
    """
    return self.__connection_points
      
  def _set_connection_points(self, v, load=False):
    """
    Setter method for connection_points, mapped from YANG variable /inputs/vnfbd/scenario/links/connection_points (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_points is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_points() directly.

    YANG Description: Reference to the connection points of nodes
the link is adjacent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_points must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='leafref', is_config=True)""",
        })

    self.__connection_points = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_points(self):
    self.__connection_points = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='leafref', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  network = __builtin__.property(_get_network, _set_network)
  connection_points = __builtin__.property(_get_connection_points, _set_connection_points)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('type', type), ('network', network), ('connection_points', connection_points), ])


class yc_policies_vnf_br__inputs_vnfbd_scenario_policies(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd/scenario/policies. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Definition of policies to be
utilized on the instantiation of the scenario.
A policy is defined by a name, it type,
the targets (nodes and/or links) to which it must be applied to,
and the proper action that realizes the policy.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__type','__targets','__action',)

  _yang_name = 'policies'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__targets = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__action = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd', 'scenario', 'policies']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /inputs/vnfbd/scenario/policies/name (string)

    YANG Description: The name of the policy.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /inputs/vnfbd/scenario/policies/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the policy.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /inputs/vnfbd/scenario/policies/type (string)

    YANG Description: The type of the policy
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /inputs/vnfbd/scenario/policies/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of the policy
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_targets(self):
    """
    Getter method for targets, mapped from YANG variable /inputs/vnfbd/scenario/policies/targets (string)

    YANG Description: The targets of the policy.
Uuid of nodes and/or links separated by comma.
    """
    return self.__targets
      
  def _set_targets(self, v, load=False):
    """
    Setter method for targets, mapped from YANG variable /inputs/vnfbd/scenario/policies/targets (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_targets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_targets() directly.

    YANG Description: The targets of the policy.
Uuid of nodes and/or links separated by comma.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """targets must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__targets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_targets(self):
    self.__targets = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_action(self):
    """
    Getter method for action, mapped from YANG variable /inputs/vnfbd/scenario/policies/action (string)

    YANG Description: The action of the policy
    """
    return self.__action
      
  def _set_action(self, v, load=False):
    """
    Setter method for action, mapped from YANG variable /inputs/vnfbd/scenario/policies/action (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_action() directly.

    YANG Description: The action of the policy
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """action must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_action(self):
    self.__action = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  targets = __builtin__.property(_get_targets, _set_targets)
  action = __builtin__.property(_get_action, _set_action)


  _pyangbind_elements = OrderedDict([('name', name), ('type', type), ('targets', targets), ('action', action), ])


class yc_scenario_vnf_br__inputs_vnfbd_scenario(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd/scenario. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Scenarios defined by this VNF-BD.
A scenario contains all information needed to describe
the deployment of all involved functional components
mandatory for the execution of a benchmarking Test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__nodes','__links','__policies',)

  _yang_name = 'scenario'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__nodes = YANGDynClass(base=YANGListType("id",yc_nodes_vnf_br__inputs_vnfbd_scenario_nodes, yang_name="nodes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    self.__links = YANGDynClass(base=YANGListType("id",yc_links_vnf_br__inputs_vnfbd_scenario_links, yang_name="links", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    self.__policies = YANGDynClass(base=YANGListType("name",yc_policies_vnf_br__inputs_vnfbd_scenario_policies, yang_name="policies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd', 'scenario']

  def _get_nodes(self):
    """
    Getter method for nodes, mapped from YANG variable /inputs/vnfbd/scenario/nodes (list)

    YANG Description: The list of nodes that must be
instantiated in a scenario in order to enable
a benchmarking Test.
    """
    return self.__nodes
      
  def _set_nodes(self, v, load=False):
    """
    Setter method for nodes, mapped from YANG variable /inputs/vnfbd/scenario/nodes (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nodes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nodes() directly.

    YANG Description: The list of nodes that must be
instantiated in a scenario in order to enable
a benchmarking Test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_nodes_vnf_br__inputs_vnfbd_scenario_nodes, yang_name="nodes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nodes must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_nodes_vnf_br__inputs_vnfbd_scenario_nodes, yang_name="nodes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__nodes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nodes(self):
    self.__nodes = YANGDynClass(base=YANGListType("id",yc_nodes_vnf_br__inputs_vnfbd_scenario_nodes, yang_name="nodes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)


  def _get_links(self):
    """
    Getter method for links, mapped from YANG variable /inputs/vnfbd/scenario/links (list)

    YANG Description: The list of links among nodes that must be
instantiated in a scenario in order to enable
a benchmarking Test.
    """
    return self.__links
      
  def _set_links(self, v, load=False):
    """
    Setter method for links, mapped from YANG variable /inputs/vnfbd/scenario/links (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_links is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_links() directly.

    YANG Description: The list of links among nodes that must be
instantiated in a scenario in order to enable
a benchmarking Test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_links_vnf_br__inputs_vnfbd_scenario_links, yang_name="links", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """links must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_links_vnf_br__inputs_vnfbd_scenario_links, yang_name="links", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__links = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_links(self):
    self.__links = YANGDynClass(base=YANGListType("id",yc_links_vnf_br__inputs_vnfbd_scenario_links, yang_name="links", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)


  def _get_policies(self):
    """
    Getter method for policies, mapped from YANG variable /inputs/vnfbd/scenario/policies (list)

    YANG Description: Definition of policies to be
utilized on the instantiation of the scenario.
A policy is defined by a name, it type,
the targets (nodes and/or links) to which it must be applied to,
and the proper action that realizes the policy.
    """
    return self.__policies
      
  def _set_policies(self, v, load=False):
    """
    Setter method for policies, mapped from YANG variable /inputs/vnfbd/scenario/policies (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policies is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policies() directly.

    YANG Description: Definition of policies to be
utilized on the instantiation of the scenario.
A policy is defined by a name, it type,
the targets (nodes and/or links) to which it must be applied to,
and the proper action that realizes the policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_policies_vnf_br__inputs_vnfbd_scenario_policies, yang_name="policies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policies must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_policies_vnf_br__inputs_vnfbd_scenario_policies, yang_name="policies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__policies = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policies(self):
    self.__policies = YANGDynClass(base=YANGListType("name",yc_policies_vnf_br__inputs_vnfbd_scenario_policies, yang_name="policies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

  nodes = __builtin__.property(_get_nodes, _set_nodes)
  links = __builtin__.property(_get_links, _set_links)
  policies = __builtin__.property(_get_policies, _set_policies)


  _pyangbind_elements = OrderedDict([('nodes', nodes), ('links', links), ('policies', policies), ])


class yc_parameters_vnf_br__inputs_vnfbd_proceedings_agents_probers_parameters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd/proceedings/agents/probers/parameters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters for the execution
of the tool. Each tool detains the proper set of running
parameters that must be utilized to realize a benchmarking
test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__input','__value',)

  _yang_name = 'parameters'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__input = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd', 'proceedings', 'agents', 'probers', 'parameters']

  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/parameters/input (string)

    YANG Description: The input key of a parameter
    """
    return self.__input
      
  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/parameters/input (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.

    YANG Description: The input key of a parameter
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/parameters/value (string)

    YANG Description: The value of a parameter
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/parameters/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: The value of a parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  input = __builtin__.property(_get_input, _set_input)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('input', input), ('value', value), ])


class yc_sched_vnf_br__inputs_vnfbd_proceedings_agents_probers_sched(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd/proceedings/agents/probers/sched. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The scheduling parameters of a tool.
Each Agent/Monitor must utilize the scheduling parameters
to perform the execution of its tools (probers/listeners)
accordingly.
  """
  __slots__ = ('_path_helper', '_extmethods', '__from_','__until','__duration','__interval','__repeat',)

  _yang_name = 'sched'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__from_ = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__until = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="until", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__duration = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__repeat = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd', 'proceedings', 'agents', 'probers', 'sched']

  def _get_from_(self):
    """
    Getter method for from_, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/sched/from (uint32)

    YANG Description: The initial time (in seconds)
of the execution of the tool.
    """
    return self.__from_
      
  def _set_from_(self, v, load=False):
    """
    Setter method for from_, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/sched/from (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_from_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_from_() directly.

    YANG Description: The initial time (in seconds)
of the execution of the tool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """from_ must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__from_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_from_(self):
    self.__from_ = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_until(self):
    """
    Getter method for until, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/sched/until (uint32)

    YANG Description: The final/maximum time (in seconds)
of the execution of the tool summed all its instances
repeat, duration and interval parameters.
    """
    return self.__until
      
  def _set_until(self, v, load=False):
    """
    Setter method for until, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/sched/until (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_until is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_until() directly.

    YANG Description: The final/maximum time (in seconds)
of the execution of the tool summed all its instances
repeat, duration and interval parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="until", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """until must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="until", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__until = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_until(self):
    self.__until = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="until", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_duration(self):
    """
    Getter method for duration, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/sched/duration (uint32)

    YANG Description: The total duration (in seconds) of the execution
of each instance of the tool.
    """
    return self.__duration
      
  def _set_duration(self, v, load=False):
    """
    Setter method for duration, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/sched/duration (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_duration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_duration() directly.

    YANG Description: The total duration (in seconds) of the execution
of each instance of the tool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """duration must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__duration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_duration(self):
    self.__duration = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/sched/interval (uint32)

    YANG Description: The interval (in seconds) to be awaited
among each one of the instances of the execution of the tool.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/sched/interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: The interval (in seconds) to be awaited
among each one of the instances of the execution of the tool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_repeat(self):
    """
    Getter method for repeat, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/sched/repeat (uint32)

    YANG Description: The number of times the tool must be executed.
    """
    return self.__repeat
      
  def _set_repeat(self, v, load=False):
    """
    Setter method for repeat, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/sched/repeat (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_repeat is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_repeat() directly.

    YANG Description: The number of times the tool must be executed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """repeat must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__repeat = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_repeat(self):
    self.__repeat = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)

  from_ = __builtin__.property(_get_from_, _set_from_)
  until = __builtin__.property(_get_until, _set_until)
  duration = __builtin__.property(_get_duration, _set_duration)
  interval = __builtin__.property(_get_interval, _set_interval)
  repeat = __builtin__.property(_get_repeat, _set_repeat)


  _pyangbind_elements = OrderedDict([('from_', from_), ('until', until), ('duration', duration), ('interval', interval), ('repeat', repeat), ])


class yc_probers_vnf_br__inputs_vnfbd_proceedings_agents_probers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd/proceedings/agents/probers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines a list of the Prober(s)
that must be used in a benchmarking test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__instances','__name','__parameters','__sched',)

  _yang_name = 'probers'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__instances = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__parameters = YANGDynClass(base=YANGListType("input",yc_parameters_vnf_br__inputs_vnfbd_proceedings_agents_probers_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    self.__sched = YANGDynClass(base=yc_sched_vnf_br__inputs_vnfbd_proceedings_agents_probers_sched, is_container='container', yang_name="sched", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd', 'proceedings', 'agents', 'probers']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/id (uint32)

    YANG Description: The unique identifier of a tool.
This information specifies how a tool can be
identified in a list of probers/listeners of an
Agent/Monitor.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The unique identifier of a tool.
This information specifies how a tool can be
identified in a list of probers/listeners of an
Agent/Monitor.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_instances(self):
    """
    Getter method for instances, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/instances (uint32)

    YANG Description: The number of the tool instances that
must be executed in parallel.
    """
    return self.__instances
      
  def _set_instances(self, v, load=False):
    """
    Setter method for instances, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/instances (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instances() directly.

    YANG Description: The number of the tool instances that
must be executed in parallel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instances must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__instances = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instances(self):
    self.__instances = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/name (string)

    YANG Description: The name of a tool.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of a tool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_parameters(self):
    """
    Getter method for parameters, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/parameters (list)

    YANG Description: List of parameters for the execution
of the tool. Each tool detains the proper set of running
parameters that must be utilized to realize a benchmarking
test.
    """
    return self.__parameters
      
  def _set_parameters(self, v, load=False):
    """
    Setter method for parameters, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/parameters (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameters() directly.

    YANG Description: List of parameters for the execution
of the tool. Each tool detains the proper set of running
parameters that must be utilized to realize a benchmarking
test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("input",yc_parameters_vnf_br__inputs_vnfbd_proceedings_agents_probers_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameters must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("input",yc_parameters_vnf_br__inputs_vnfbd_proceedings_agents_probers_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__parameters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameters(self):
    self.__parameters = YANGDynClass(base=YANGListType("input",yc_parameters_vnf_br__inputs_vnfbd_proceedings_agents_probers_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)


  def _get_sched(self):
    """
    Getter method for sched, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/sched (container)

    YANG Description: The scheduling parameters of a tool.
Each Agent/Monitor must utilize the scheduling parameters
to perform the execution of its tools (probers/listeners)
accordingly.
    """
    return self.__sched
      
  def _set_sched(self, v, load=False):
    """
    Setter method for sched, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers/sched (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sched is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sched() directly.

    YANG Description: The scheduling parameters of a tool.
Each Agent/Monitor must utilize the scheduling parameters
to perform the execution of its tools (probers/listeners)
accordingly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_sched_vnf_br__inputs_vnfbd_proceedings_agents_probers_sched, is_container='container', yang_name="sched", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sched must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_sched_vnf_br__inputs_vnfbd_proceedings_agents_probers_sched, is_container='container', yang_name="sched", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__sched = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sched(self):
    self.__sched = YANGDynClass(base=yc_sched_vnf_br__inputs_vnfbd_proceedings_agents_probers_sched, is_container='container', yang_name="sched", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  instances = __builtin__.property(_get_instances, _set_instances)
  name = __builtin__.property(_get_name, _set_name)
  parameters = __builtin__.property(_get_parameters, _set_parameters)
  sched = __builtin__.property(_get_sched, _set_sched)


  _pyangbind_elements = OrderedDict([('id', id), ('instances', instances), ('name', name), ('parameters', parameters), ('sched', sched), ])


class yc_agents_vnf_br__inputs_vnfbd_proceedings_agents(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd/proceedings/agents. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines a list containing the
Agent(s) needed for a VNF-BD test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__uuid','__name','__probers',)

  _yang_name = 'agents'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__probers = YANGDynClass(base=YANGListType("id",yc_probers_vnf_br__inputs_vnfbd_proceedings_agents_probers, yang_name="probers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="probers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd', 'proceedings', 'agents']

  def _get_uuid(self):
    """
    Getter method for uuid, mapped from YANG variable /inputs/vnfbd/proceedings/agents/uuid (string)

    YANG Description: A unique identifier
    """
    return self.__uuid
      
  def _set_uuid(self, v, load=False):
    """
    Setter method for uuid, mapped from YANG variable /inputs/vnfbd/proceedings/agents/uuid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uuid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uuid() directly.

    YANG Description: A unique identifier
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uuid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__uuid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uuid(self):
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /inputs/vnfbd/proceedings/agents/name (string)

    YANG Description: The name of component
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /inputs/vnfbd/proceedings/agents/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of component
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_probers(self):
    """
    Getter method for probers, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers (list)

    YANG Description: Defines a list of the Prober(s)
that must be used in a benchmarking test.
    """
    return self.__probers
      
  def _set_probers(self, v, load=False):
    """
    Setter method for probers, mapped from YANG variable /inputs/vnfbd/proceedings/agents/probers (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_probers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_probers() directly.

    YANG Description: Defines a list of the Prober(s)
that must be used in a benchmarking test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_probers_vnf_br__inputs_vnfbd_proceedings_agents_probers, yang_name="probers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="probers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """probers must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_probers_vnf_br__inputs_vnfbd_proceedings_agents_probers, yang_name="probers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="probers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__probers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_probers(self):
    self.__probers = YANGDynClass(base=YANGListType("id",yc_probers_vnf_br__inputs_vnfbd_proceedings_agents_probers, yang_name="probers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="probers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

  uuid = __builtin__.property(_get_uuid, _set_uuid)
  name = __builtin__.property(_get_name, _set_name)
  probers = __builtin__.property(_get_probers, _set_probers)


  _pyangbind_elements = OrderedDict([('uuid', uuid), ('name', name), ('probers', probers), ])


class yc_parameters_vnf_br__inputs_vnfbd_proceedings_monitors_listeners_parameters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd/proceedings/monitors/listeners/parameters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters for the execution
of the tool. Each tool detains the proper set of running
parameters that must be utilized to realize a benchmarking
test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__input','__value',)

  _yang_name = 'parameters'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__input = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd', 'proceedings', 'monitors', 'listeners', 'parameters']

  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/parameters/input (string)

    YANG Description: The input key of a parameter
    """
    return self.__input
      
  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/parameters/input (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.

    YANG Description: The input key of a parameter
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/parameters/value (string)

    YANG Description: The value of a parameter
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/parameters/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: The value of a parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  input = __builtin__.property(_get_input, _set_input)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('input', input), ('value', value), ])


class yc_sched_vnf_br__inputs_vnfbd_proceedings_monitors_listeners_sched(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd/proceedings/monitors/listeners/sched. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The scheduling parameters of a tool.
Each Agent/Monitor must utilize the scheduling parameters
to perform the execution of its tools (probers/listeners)
accordingly.
  """
  __slots__ = ('_path_helper', '_extmethods', '__from_','__until','__duration','__interval','__repeat',)

  _yang_name = 'sched'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__from_ = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__until = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="until", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__duration = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__repeat = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd', 'proceedings', 'monitors', 'listeners', 'sched']

  def _get_from_(self):
    """
    Getter method for from_, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/sched/from (uint32)

    YANG Description: The initial time (in seconds)
of the execution of the tool.
    """
    return self.__from_
      
  def _set_from_(self, v, load=False):
    """
    Setter method for from_, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/sched/from (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_from_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_from_() directly.

    YANG Description: The initial time (in seconds)
of the execution of the tool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """from_ must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__from_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_from_(self):
    self.__from_ = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_until(self):
    """
    Getter method for until, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/sched/until (uint32)

    YANG Description: The final/maximum time (in seconds)
of the execution of the tool summed all its instances
repeat, duration and interval parameters.
    """
    return self.__until
      
  def _set_until(self, v, load=False):
    """
    Setter method for until, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/sched/until (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_until is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_until() directly.

    YANG Description: The final/maximum time (in seconds)
of the execution of the tool summed all its instances
repeat, duration and interval parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="until", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """until must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="until", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__until = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_until(self):
    self.__until = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="until", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_duration(self):
    """
    Getter method for duration, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/sched/duration (uint32)

    YANG Description: The total duration (in seconds) of the execution
of each instance of the tool.
    """
    return self.__duration
      
  def _set_duration(self, v, load=False):
    """
    Setter method for duration, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/sched/duration (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_duration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_duration() directly.

    YANG Description: The total duration (in seconds) of the execution
of each instance of the tool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """duration must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__duration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_duration(self):
    self.__duration = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/sched/interval (uint32)

    YANG Description: The interval (in seconds) to be awaited
among each one of the instances of the execution of the tool.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/sched/interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: The interval (in seconds) to be awaited
among each one of the instances of the execution of the tool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_repeat(self):
    """
    Getter method for repeat, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/sched/repeat (uint32)

    YANG Description: The number of times the tool must be executed.
    """
    return self.__repeat
      
  def _set_repeat(self, v, load=False):
    """
    Setter method for repeat, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/sched/repeat (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_repeat is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_repeat() directly.

    YANG Description: The number of times the tool must be executed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """repeat must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__repeat = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_repeat(self):
    self.__repeat = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)

  from_ = __builtin__.property(_get_from_, _set_from_)
  until = __builtin__.property(_get_until, _set_until)
  duration = __builtin__.property(_get_duration, _set_duration)
  interval = __builtin__.property(_get_interval, _set_interval)
  repeat = __builtin__.property(_get_repeat, _set_repeat)


  _pyangbind_elements = OrderedDict([('from_', from_), ('until', until), ('duration', duration), ('interval', interval), ('repeat', repeat), ])


class yc_listeners_vnf_br__inputs_vnfbd_proceedings_monitors_listeners(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd/proceedings/monitors/listeners. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines a list of the Listeners(s)
that must used in a benchmarking test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__instances','__name','__parameters','__sched',)

  _yang_name = 'listeners'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__instances = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__parameters = YANGDynClass(base=YANGListType("input",yc_parameters_vnf_br__inputs_vnfbd_proceedings_monitors_listeners_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    self.__sched = YANGDynClass(base=yc_sched_vnf_br__inputs_vnfbd_proceedings_monitors_listeners_sched, is_container='container', yang_name="sched", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd', 'proceedings', 'monitors', 'listeners']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/id (uint32)

    YANG Description: The unique identifier of a tool.
This information specifies how a tool can be
identified in a list of probers/listeners of an
Agent/Monitor.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The unique identifier of a tool.
This information specifies how a tool can be
identified in a list of probers/listeners of an
Agent/Monitor.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_instances(self):
    """
    Getter method for instances, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/instances (uint32)

    YANG Description: The number of the tool instances that
must be executed in parallel.
    """
    return self.__instances
      
  def _set_instances(self, v, load=False):
    """
    Setter method for instances, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/instances (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instances() directly.

    YANG Description: The number of the tool instances that
must be executed in parallel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instances must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__instances = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instances(self):
    self.__instances = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/name (string)

    YANG Description: The name of a tool.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of a tool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_parameters(self):
    """
    Getter method for parameters, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/parameters (list)

    YANG Description: List of parameters for the execution
of the tool. Each tool detains the proper set of running
parameters that must be utilized to realize a benchmarking
test.
    """
    return self.__parameters
      
  def _set_parameters(self, v, load=False):
    """
    Setter method for parameters, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/parameters (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameters() directly.

    YANG Description: List of parameters for the execution
of the tool. Each tool detains the proper set of running
parameters that must be utilized to realize a benchmarking
test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("input",yc_parameters_vnf_br__inputs_vnfbd_proceedings_monitors_listeners_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameters must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("input",yc_parameters_vnf_br__inputs_vnfbd_proceedings_monitors_listeners_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__parameters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameters(self):
    self.__parameters = YANGDynClass(base=YANGListType("input",yc_parameters_vnf_br__inputs_vnfbd_proceedings_monitors_listeners_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)


  def _get_sched(self):
    """
    Getter method for sched, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/sched (container)

    YANG Description: The scheduling parameters of a tool.
Each Agent/Monitor must utilize the scheduling parameters
to perform the execution of its tools (probers/listeners)
accordingly.
    """
    return self.__sched
      
  def _set_sched(self, v, load=False):
    """
    Setter method for sched, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners/sched (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sched is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sched() directly.

    YANG Description: The scheduling parameters of a tool.
Each Agent/Monitor must utilize the scheduling parameters
to perform the execution of its tools (probers/listeners)
accordingly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_sched_vnf_br__inputs_vnfbd_proceedings_monitors_listeners_sched, is_container='container', yang_name="sched", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sched must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_sched_vnf_br__inputs_vnfbd_proceedings_monitors_listeners_sched, is_container='container', yang_name="sched", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__sched = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sched(self):
    self.__sched = YANGDynClass(base=yc_sched_vnf_br__inputs_vnfbd_proceedings_monitors_listeners_sched, is_container='container', yang_name="sched", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  instances = __builtin__.property(_get_instances, _set_instances)
  name = __builtin__.property(_get_name, _set_name)
  parameters = __builtin__.property(_get_parameters, _set_parameters)
  sched = __builtin__.property(_get_sched, _set_sched)


  _pyangbind_elements = OrderedDict([('id', id), ('instances', instances), ('name', name), ('parameters', parameters), ('sched', sched), ])


class yc_monitors_vnf_br__inputs_vnfbd_proceedings_monitors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd/proceedings/monitors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines a list containing the
Monitor(s) needed for a VNF-BD test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__uuid','__name','__listeners',)

  _yang_name = 'monitors'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__listeners = YANGDynClass(base=YANGListType("id",yc_listeners_vnf_br__inputs_vnfbd_proceedings_monitors_listeners, yang_name="listeners", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="listeners", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd', 'proceedings', 'monitors']

  def _get_uuid(self):
    """
    Getter method for uuid, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/uuid (string)

    YANG Description: A unique identifier
    """
    return self.__uuid
      
  def _set_uuid(self, v, load=False):
    """
    Setter method for uuid, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/uuid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uuid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uuid() directly.

    YANG Description: A unique identifier
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uuid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__uuid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uuid(self):
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/name (string)

    YANG Description: The name of component
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of component
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_listeners(self):
    """
    Getter method for listeners, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners (list)

    YANG Description: Defines a list of the Listeners(s)
that must used in a benchmarking test.
    """
    return self.__listeners
      
  def _set_listeners(self, v, load=False):
    """
    Setter method for listeners, mapped from YANG variable /inputs/vnfbd/proceedings/monitors/listeners (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_listeners is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_listeners() directly.

    YANG Description: Defines a list of the Listeners(s)
that must used in a benchmarking test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_listeners_vnf_br__inputs_vnfbd_proceedings_monitors_listeners, yang_name="listeners", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="listeners", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """listeners must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_listeners_vnf_br__inputs_vnfbd_proceedings_monitors_listeners, yang_name="listeners", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="listeners", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__listeners = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_listeners(self):
    self.__listeners = YANGDynClass(base=YANGListType("id",yc_listeners_vnf_br__inputs_vnfbd_proceedings_monitors_listeners, yang_name="listeners", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="listeners", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

  uuid = __builtin__.property(_get_uuid, _set_uuid)
  name = __builtin__.property(_get_name, _set_name)
  listeners = __builtin__.property(_get_listeners, _set_listeners)


  _pyangbind_elements = OrderedDict([('uuid', uuid), ('name', name), ('listeners', listeners), ])


class yc_proceedings_vnf_br__inputs_vnfbd_proceedings(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd/proceedings. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Proceedings of VNF-BD.
The proceedings are utilized by the Manager component
to execute a benchmarking Test. It consists of
agent(s)/monitor(s) settings, detailing their prober(s)/listener(s)
specification and running parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__agents','__monitors',)

  _yang_name = 'proceedings'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__agents = YANGDynClass(base=YANGListType("uuid",yc_agents_vnf_br__inputs_vnfbd_proceedings_agents, yang_name="agents", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="agents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    self.__monitors = YANGDynClass(base=YANGListType("uuid",yc_monitors_vnf_br__inputs_vnfbd_proceedings_monitors, yang_name="monitors", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd', 'proceedings']

  def _get_agents(self):
    """
    Getter method for agents, mapped from YANG variable /inputs/vnfbd/proceedings/agents (list)

    YANG Description: Defines a list containing the
Agent(s) needed for a VNF-BD test.
    """
    return self.__agents
      
  def _set_agents(self, v, load=False):
    """
    Setter method for agents, mapped from YANG variable /inputs/vnfbd/proceedings/agents (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_agents is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_agents() directly.

    YANG Description: Defines a list containing the
Agent(s) needed for a VNF-BD test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("uuid",yc_agents_vnf_br__inputs_vnfbd_proceedings_agents, yang_name="agents", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="agents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """agents must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("uuid",yc_agents_vnf_br__inputs_vnfbd_proceedings_agents, yang_name="agents", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="agents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__agents = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_agents(self):
    self.__agents = YANGDynClass(base=YANGListType("uuid",yc_agents_vnf_br__inputs_vnfbd_proceedings_agents, yang_name="agents", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="agents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)


  def _get_monitors(self):
    """
    Getter method for monitors, mapped from YANG variable /inputs/vnfbd/proceedings/monitors (list)

    YANG Description: Defines a list containing the
Monitor(s) needed for a VNF-BD test.
    """
    return self.__monitors
      
  def _set_monitors(self, v, load=False):
    """
    Setter method for monitors, mapped from YANG variable /inputs/vnfbd/proceedings/monitors (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitors() directly.

    YANG Description: Defines a list containing the
Monitor(s) needed for a VNF-BD test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("uuid",yc_monitors_vnf_br__inputs_vnfbd_proceedings_monitors, yang_name="monitors", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """monitors must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("uuid",yc_monitors_vnf_br__inputs_vnfbd_proceedings_monitors, yang_name="monitors", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__monitors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_monitors(self):
    self.__monitors = YANGDynClass(base=YANGListType("uuid",yc_monitors_vnf_br__inputs_vnfbd_proceedings_monitors, yang_name="monitors", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

  agents = __builtin__.property(_get_agents, _set_agents)
  monitors = __builtin__.property(_get_monitors, _set_monitors)


  _pyangbind_elements = OrderedDict([('agents', agents), ('monitors', monitors), ])


class yc_vnfbd_vnf_br__inputs_vnfbd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs/vnfbd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The input VNF-BD.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__version','__description','__timestamp','__experiments','__scenario','__proceedings',)

  _yang_name = 'vnfbd'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__timestamp = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__experiments = YANGDynClass(base=yc_experiments_vnf_br__inputs_vnfbd_experiments, is_container='container', yang_name="experiments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    self.__scenario = YANGDynClass(base=yc_scenario_vnf_br__inputs_vnfbd_scenario, is_container='container', yang_name="scenario", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    self.__proceedings = YANGDynClass(base=yc_proceedings_vnf_br__inputs_vnfbd_proceedings, is_container='container', yang_name="proceedings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs', 'vnfbd']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /inputs/vnfbd/id (string)

    YANG Description: Unique identifier of the VNF-BD.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /inputs/vnfbd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of the VNF-BD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /inputs/vnfbd/name (string)

    YANG Description: Name of the VNF-BD.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /inputs/vnfbd/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the VNF-BD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /inputs/vnfbd/version (string)

    YANG Description: Version of the VNF-BD.
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /inputs/vnfbd/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Version of the VNF-BD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /inputs/vnfbd/description (string)

    YANG Description: Description of the VNF-BD
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /inputs/vnfbd/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the VNF-BD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_timestamp(self):
    """
    Getter method for timestamp, mapped from YANG variable /inputs/vnfbd/timestamp (string)

    YANG Description: Time (date, hour, minute, second)
when the VNF-BD was created.
    """
    return self.__timestamp
      
  def _set_timestamp(self, v, load=False):
    """
    Setter method for timestamp, mapped from YANG variable /inputs/vnfbd/timestamp (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timestamp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timestamp() directly.

    YANG Description: Time (date, hour, minute, second)
when the VNF-BD was created.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timestamp must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__timestamp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timestamp(self):
    self.__timestamp = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_experiments(self):
    """
    Getter method for experiments, mapped from YANG variable /inputs/vnfbd/experiments (container)

    YANG Description: Defines the number of trials and tests
the VNF-BD must execute.
    """
    return self.__experiments
      
  def _set_experiments(self, v, load=False):
    """
    Setter method for experiments, mapped from YANG variable /inputs/vnfbd/experiments (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_experiments is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_experiments() directly.

    YANG Description: Defines the number of trials and tests
the VNF-BD must execute.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_experiments_vnf_br__inputs_vnfbd_experiments, is_container='container', yang_name="experiments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """experiments must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_experiments_vnf_br__inputs_vnfbd_experiments, is_container='container', yang_name="experiments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__experiments = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_experiments(self):
    self.__experiments = YANGDynClass(base=yc_experiments_vnf_br__inputs_vnfbd_experiments, is_container='container', yang_name="experiments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)


  def _get_scenario(self):
    """
    Getter method for scenario, mapped from YANG variable /inputs/vnfbd/scenario (container)

    YANG Description: Scenarios defined by this VNF-BD.
A scenario contains all information needed to describe
the deployment of all involved functional components
mandatory for the execution of a benchmarking Test.
    """
    return self.__scenario
      
  def _set_scenario(self, v, load=False):
    """
    Setter method for scenario, mapped from YANG variable /inputs/vnfbd/scenario (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scenario is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scenario() directly.

    YANG Description: Scenarios defined by this VNF-BD.
A scenario contains all information needed to describe
the deployment of all involved functional components
mandatory for the execution of a benchmarking Test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_scenario_vnf_br__inputs_vnfbd_scenario, is_container='container', yang_name="scenario", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scenario must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_scenario_vnf_br__inputs_vnfbd_scenario, is_container='container', yang_name="scenario", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__scenario = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scenario(self):
    self.__scenario = YANGDynClass(base=yc_scenario_vnf_br__inputs_vnfbd_scenario, is_container='container', yang_name="scenario", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)


  def _get_proceedings(self):
    """
    Getter method for proceedings, mapped from YANG variable /inputs/vnfbd/proceedings (container)

    YANG Description: Proceedings of VNF-BD.
The proceedings are utilized by the Manager component
to execute a benchmarking Test. It consists of
agent(s)/monitor(s) settings, detailing their prober(s)/listener(s)
specification and running parameters.
    """
    return self.__proceedings
      
  def _set_proceedings(self, v, load=False):
    """
    Setter method for proceedings, mapped from YANG variable /inputs/vnfbd/proceedings (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proceedings is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proceedings() directly.

    YANG Description: Proceedings of VNF-BD.
The proceedings are utilized by the Manager component
to execute a benchmarking Test. It consists of
agent(s)/monitor(s) settings, detailing their prober(s)/listener(s)
specification and running parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_proceedings_vnf_br__inputs_vnfbd_proceedings, is_container='container', yang_name="proceedings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """proceedings must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_proceedings_vnf_br__inputs_vnfbd_proceedings, is_container='container', yang_name="proceedings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__proceedings = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_proceedings(self):
    self.__proceedings = YANGDynClass(base=yc_proceedings_vnf_br__inputs_vnfbd_proceedings, is_container='container', yang_name="proceedings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  version = __builtin__.property(_get_version, _set_version)
  description = __builtin__.property(_get_description, _set_description)
  timestamp = __builtin__.property(_get_timestamp, _set_timestamp)
  experiments = __builtin__.property(_get_experiments, _set_experiments)
  scenario = __builtin__.property(_get_scenario, _set_scenario)
  proceedings = __builtin__.property(_get_proceedings, _set_proceedings)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('version', version), ('description', description), ('timestamp', timestamp), ('experiments', experiments), ('scenario', scenario), ('proceedings', proceedings), ])


class yc_inputs_vnf_br__inputs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /inputs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The inputs needed to
realize a VNF-BR.
  """
  __slots__ = ('_path_helper', '_extmethods', '__variables','__vnfbd',)

  _yang_name = 'inputs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__variables = YANGDynClass(base=YANGListType("name",yc_variables_vnf_br__inputs_variables, yang_name="variables", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="variables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    self.__vnfbd = YANGDynClass(base=yc_vnfbd_vnf_br__inputs_vnfbd, is_container='container', yang_name="vnfbd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['inputs']

  def _get_variables(self):
    """
    Getter method for variables, mapped from YANG variable /inputs/variables (list)

    YANG Description: The list of
input variables.
    """
    return self.__variables
      
  def _set_variables(self, v, load=False):
    """
    Setter method for variables, mapped from YANG variable /inputs/variables (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_variables is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_variables() directly.

    YANG Description: The list of
input variables.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_variables_vnf_br__inputs_variables, yang_name="variables", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="variables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """variables must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_variables_vnf_br__inputs_variables, yang_name="variables", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="variables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__variables = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_variables(self):
    self.__variables = YANGDynClass(base=YANGListType("name",yc_variables_vnf_br__inputs_variables, yang_name="variables", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="variables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)


  def _get_vnfbd(self):
    """
    Getter method for vnfbd, mapped from YANG variable /inputs/vnfbd (container)

    YANG Description: The input VNF-BD.
    """
    return self.__vnfbd
      
  def _set_vnfbd(self, v, load=False):
    """
    Setter method for vnfbd, mapped from YANG variable /inputs/vnfbd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfbd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfbd() directly.

    YANG Description: The input VNF-BD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vnfbd_vnf_br__inputs_vnfbd, is_container='container', yang_name="vnfbd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfbd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vnfbd_vnf_br__inputs_vnfbd, is_container='container', yang_name="vnfbd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__vnfbd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfbd(self):
    self.__vnfbd = YANGDynClass(base=yc_vnfbd_vnf_br__inputs_vnfbd, is_container='container', yang_name="vnfbd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)

  variables = __builtin__.property(_get_variables, _set_variables)
  vnfbd = __builtin__.property(_get_vnfbd, _set_vnfbd)


  _pyangbind_elements = OrderedDict([('variables', variables), ('vnfbd', vnfbd), ])


class yc_variables_vnf_br__outputs_variables(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/variables. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of instance of varibles
from VNF-BR:inputs utilized by a VNF-BD to
generate a VNF-PP.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__value',)

  _yang_name = 'variables'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'variables']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /outputs/variables/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /outputs/variables/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /outputs/variables/value (string)
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /outputs/variables/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('name', name), ('value', value), ])


class yc_experiments_vnf_br__outputs_vnfbd_experiments(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd/experiments. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines the number of trials and tests
the VNF-BD must execute.
  """
  __slots__ = ('_path_helper', '_extmethods', '__trials','__tests',)

  _yang_name = 'experiments'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__trials = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="trials", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__tests = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="tests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd', 'experiments']

  def _get_trials(self):
    """
    Getter method for trials, mapped from YANG variable /outputs/vnfbd/experiments/trials (uint32)

    YANG Description: Number of trials.
A trial is a single process or iteration
to obtain VNF performance metrics from
benchmarking the VNF-BD proceedings.
    """
    return self.__trials
      
  def _set_trials(self, v, load=False):
    """
    Setter method for trials, mapped from YANG variable /outputs/vnfbd/experiments/trials (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trials is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trials() directly.

    YANG Description: Number of trials.
A trial is a single process or iteration
to obtain VNF performance metrics from
benchmarking the VNF-BD proceedings.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="trials", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trials must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="trials", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__trials = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trials(self):
    self.__trials = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="trials", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_tests(self):
    """
    Getter method for tests, mapped from YANG variable /outputs/vnfbd/experiments/tests (uint32)

    YANG Description: Number of tests.
Each test defines unique structural
and functional parameters (e.g., configurations,
resource assignment) for benchmarked components
to perform one or multiple Trials.
Each Test must be executed following a
particular scenario.
    """
    return self.__tests
      
  def _set_tests(self, v, load=False):
    """
    Setter method for tests, mapped from YANG variable /outputs/vnfbd/experiments/tests (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tests is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tests() directly.

    YANG Description: Number of tests.
Each test defines unique structural
and functional parameters (e.g., configurations,
resource assignment) for benchmarked components
to perform one or multiple Trials.
Each Test must be executed following a
particular scenario.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="tests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tests must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="tests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__tests = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tests(self):
    self.__tests = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="tests", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)

  trials = __builtin__.property(_get_trials, _set_trials)
  tests = __builtin__.property(_get_tests, _set_tests)


  _pyangbind_elements = OrderedDict([('trials', trials), ('tests', tests), ])


class yc_cpu_vnf_br__outputs_vnfbd_scenario_nodes_resources_cpu(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd/scenario/nodes/resources/cpu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The node CPU resources that must
be allocated for a benchmarking Test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vcpus','__cpu_bw','__pinning',)

  _yang_name = 'cpu'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__vcpus = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vcpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__cpu_bw = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpu_bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__pinning = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pinning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd', 'scenario', 'nodes', 'resources', 'cpu']

  def _get_vcpus(self):
    """
    Getter method for vcpus, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources/cpu/vcpus (uint32)

    YANG Description: The number of cores to be allocated
for a node.
    """
    return self.__vcpus
      
  def _set_vcpus(self, v, load=False):
    """
    Setter method for vcpus, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources/cpu/vcpus (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vcpus is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vcpus() directly.

    YANG Description: The number of cores to be allocated
for a node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vcpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vcpus must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vcpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__vcpus = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vcpus(self):
    self.__vcpus = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vcpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_cpu_bw(self):
    """
    Getter method for cpu_bw, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources/cpu/cpu_bw (string)

    YANG Description: The CPU bandwidth (CFS limit in 0.01-1.0)
    """
    return self.__cpu_bw
      
  def _set_cpu_bw(self, v, load=False):
    """
    Setter method for cpu_bw, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources/cpu/cpu_bw (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_bw is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_bw() directly.

    YANG Description: The CPU bandwidth (CFS limit in 0.01-1.0)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cpu_bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_bw must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpu_bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__cpu_bw = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_bw(self):
    self.__cpu_bw = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpu_bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_pinning(self):
    """
    Getter method for pinning, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources/cpu/pinning (string)

    YANG Description: The list of CPU cores, separated by comma,
that a node must be pinned to.
    """
    return self.__pinning
      
  def _set_pinning(self, v, load=False):
    """
    Setter method for pinning, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources/cpu/pinning (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pinning is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pinning() directly.

    YANG Description: The list of CPU cores, separated by comma,
that a node must be pinned to.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="pinning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pinning must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pinning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__pinning = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pinning(self):
    self.__pinning = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pinning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  vcpus = __builtin__.property(_get_vcpus, _set_vcpus)
  cpu_bw = __builtin__.property(_get_cpu_bw, _set_cpu_bw)
  pinning = __builtin__.property(_get_pinning, _set_pinning)


  _pyangbind_elements = OrderedDict([('vcpus', vcpus), ('cpu_bw', cpu_bw), ('pinning', pinning), ])


class yc_memory_vnf_br__outputs_vnfbd_scenario_nodes_resources_memory(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd/scenario/nodes/resources/memory. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The node memory resources
that must be allocated for a benchmarking
Test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__size','__unit',)

  _yang_name = 'memory'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__unit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd', 'scenario', 'nodes', 'resources', 'memory']

  def _get_size(self):
    """
    Getter method for size, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources/memory/size (uint32)

    YANG Description: The memory allocation size.
    """
    return self.__size
      
  def _set_size(self, v, load=False):
    """
    Setter method for size, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources/memory/size (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_size() directly.

    YANG Description: The memory allocation size.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """size must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_size(self):
    self.__size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_unit(self):
    """
    Getter method for unit, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources/memory/unit (string)

    YANG Description: The memory unit.
    """
    return self.__unit
      
  def _set_unit(self, v, load=False):
    """
    Setter method for unit, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources/memory/unit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unit() directly.

    YANG Description: The memory unit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__unit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unit(self):
    self.__unit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  size = __builtin__.property(_get_size, _set_size)
  unit = __builtin__.property(_get_unit, _set_unit)


  _pyangbind_elements = OrderedDict([('size', size), ('unit', unit), ])


class yc_storage_vnf_br__outputs_vnfbd_scenario_nodes_resources_storage(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd/scenario/nodes/resources/storage. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The node storage resources
that must be allocated for a benchmarking Test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__size','__unit','__volumes',)

  _yang_name = 'storage'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__unit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__volumes = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="volumes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd', 'scenario', 'nodes', 'resources', 'storage']

  def _get_size(self):
    """
    Getter method for size, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources/storage/size (uint32)

    YANG Description: The storage allocation size.
    """
    return self.__size
      
  def _set_size(self, v, load=False):
    """
    Setter method for size, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources/storage/size (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_size() directly.

    YANG Description: The storage allocation size.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """size must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_size(self):
    self.__size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_unit(self):
    """
    Getter method for unit, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources/storage/unit (string)

    YANG Description: The storage unit.
    """
    return self.__unit
      
  def _set_unit(self, v, load=False):
    """
    Setter method for unit, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources/storage/unit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unit() directly.

    YANG Description: The storage unit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__unit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unit(self):
    self.__unit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_volumes(self):
    """
    Getter method for volumes, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources/storage/volumes (string)

    YANG Description: Volumes to be allocated by
a node storage.
A volume defines a mapping of an outside storage
partition inside the node storage system.
Volumes must be separated by comma and be defined
using a colon to separate the node internal and external
references of storage system paths.
    """
    return self.__volumes
      
  def _set_volumes(self, v, load=False):
    """
    Setter method for volumes, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources/storage/volumes (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_volumes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_volumes() directly.

    YANG Description: Volumes to be allocated by
a node storage.
A volume defines a mapping of an outside storage
partition inside the node storage system.
Volumes must be separated by comma and be defined
using a colon to separate the node internal and external
references of storage system paths.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="volumes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """volumes must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="volumes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__volumes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_volumes(self):
    self.__volumes = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="volumes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  size = __builtin__.property(_get_size, _set_size)
  unit = __builtin__.property(_get_unit, _set_unit)
  volumes = __builtin__.property(_get_volumes, _set_volumes)


  _pyangbind_elements = OrderedDict([('size', size), ('unit', unit), ('volumes', volumes), ])


class yc_resources_vnf_br__outputs_vnfbd_scenario_nodes_resources(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd/scenario/nodes/resources. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The set of resources that must be allocated
for a node in a benchmarking Test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__cpu','__memory','__storage',)

  _yang_name = 'resources'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__cpu = YANGDynClass(base=yc_cpu_vnf_br__outputs_vnfbd_scenario_nodes_resources_cpu, is_container='container', yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    self.__memory = YANGDynClass(base=yc_memory_vnf_br__outputs_vnfbd_scenario_nodes_resources_memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    self.__storage = YANGDynClass(base=yc_storage_vnf_br__outputs_vnfbd_scenario_nodes_resources_storage, is_container='container', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd', 'scenario', 'nodes', 'resources']

  def _get_cpu(self):
    """
    Getter method for cpu, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources/cpu (container)

    YANG Description: The node CPU resources that must
be allocated for a benchmarking Test.
    """
    return self.__cpu
      
  def _set_cpu(self, v, load=False):
    """
    Setter method for cpu, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources/cpu (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu() directly.

    YANG Description: The node CPU resources that must
be allocated for a benchmarking Test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_cpu_vnf_br__outputs_vnfbd_scenario_nodes_resources_cpu, is_container='container', yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_cpu_vnf_br__outputs_vnfbd_scenario_nodes_resources_cpu, is_container='container', yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__cpu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu(self):
    self.__cpu = YANGDynClass(base=yc_cpu_vnf_br__outputs_vnfbd_scenario_nodes_resources_cpu, is_container='container', yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)


  def _get_memory(self):
    """
    Getter method for memory, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources/memory (container)

    YANG Description: The node memory resources
that must be allocated for a benchmarking
Test.
    """
    return self.__memory
      
  def _set_memory(self, v, load=False):
    """
    Setter method for memory, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources/memory (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory() directly.

    YANG Description: The node memory resources
that must be allocated for a benchmarking
Test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_memory_vnf_br__outputs_vnfbd_scenario_nodes_resources_memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """memory must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_memory_vnf_br__outputs_vnfbd_scenario_nodes_resources_memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__memory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_memory(self):
    self.__memory = YANGDynClass(base=yc_memory_vnf_br__outputs_vnfbd_scenario_nodes_resources_memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)


  def _get_storage(self):
    """
    Getter method for storage, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources/storage (container)

    YANG Description: The node storage resources
that must be allocated for a benchmarking Test.
    """
    return self.__storage
      
  def _set_storage(self, v, load=False):
    """
    Setter method for storage, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources/storage (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_storage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_storage() directly.

    YANG Description: The node storage resources
that must be allocated for a benchmarking Test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_storage_vnf_br__outputs_vnfbd_scenario_nodes_resources_storage, is_container='container', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """storage must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_storage_vnf_br__outputs_vnfbd_scenario_nodes_resources_storage, is_container='container', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__storage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_storage(self):
    self.__storage = YANGDynClass(base=yc_storage_vnf_br__outputs_vnfbd_scenario_nodes_resources_storage, is_container='container', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)

  cpu = __builtin__.property(_get_cpu, _set_cpu)
  memory = __builtin__.property(_get_memory, _set_memory)
  storage = __builtin__.property(_get_storage, _set_storage)


  _pyangbind_elements = OrderedDict([('cpu', cpu), ('memory', memory), ('storage', storage), ])


class yc_connection_points_vnf_br__outputs_vnfbd_scenario_nodes_connection_points(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd/scenario/nodes/connection_points. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of connection points of a node.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__interface','__type','__address',)

  _yang_name = 'connection_points'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd', 'scenario', 'nodes', 'connection_points']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /outputs/vnfbd/scenario/nodes/connection_points/id (string)

    YANG Description: The connection-point
unique identifier
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /outputs/vnfbd/scenario/nodes/connection_points/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The connection-point
unique identifier
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /outputs/vnfbd/scenario/nodes/connection_points/interface (string)

    YANG Description: The name of the node interface
associated with the connection-point.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /outputs/vnfbd/scenario/nodes/connection_points/interface (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: The name of the node interface
associated with the connection-point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /outputs/vnfbd/scenario/nodes/connection_points/type (string)

    YANG Description: The type of the network the
connection-point interface is attached to.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /outputs/vnfbd/scenario/nodes/connection_points/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of the network the
connection-point interface is attached to.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /outputs/vnfbd/scenario/nodes/connection_points/address (string)

    YANG Description: The Network address of the
connection-point. It can be specified as a
Ethernet MAC address, a IPv4 address or an IPv6 address.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /outputs/vnfbd/scenario/nodes/connection_points/address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: The Network address of the
connection-point. It can be specified as a
Ethernet MAC address, a IPv4 address or an IPv6 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  interface = __builtin__.property(_get_interface, _set_interface)
  type = __builtin__.property(_get_type, _set_type)
  address = __builtin__.property(_get_address, _set_address)


  _pyangbind_elements = OrderedDict([('id', id), ('interface', interface), ('type', type), ('address', address), ])


class yc_relationships_vnf_br__outputs_vnfbd_scenario_nodes_relationships(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd/scenario/nodes/relationships. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Relationship of a node with the other
scenario components.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__type','__target',)

  _yang_name = 'relationships'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__target = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd', 'scenario', 'nodes', 'relationships']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /outputs/vnfbd/scenario/nodes/relationships/name (string)

    YANG Description: Name of the relationship.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /outputs/vnfbd/scenario/nodes/relationships/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the relationship.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /outputs/vnfbd/scenario/nodes/relationships/type (string)

    YANG Description: Type of the relationship.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /outputs/vnfbd/scenario/nodes/relationships/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the relationship.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_target(self):
    """
    Getter method for target, mapped from YANG variable /outputs/vnfbd/scenario/nodes/relationships/target (string)

    YANG Description: Target of the relationship.
    """
    return self.__target
      
  def _set_target(self, v, load=False):
    """
    Setter method for target, mapped from YANG variable /outputs/vnfbd/scenario/nodes/relationships/target (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target() directly.

    YANG Description: Target of the relationship.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__target = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target(self):
    self.__target = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  target = __builtin__.property(_get_target, _set_target)


  _pyangbind_elements = OrderedDict([('name', name), ('type', type), ('target', target), ])


class yc_parameters_vnf_br__outputs_vnfbd_scenario_nodes_lifecycle_parameters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd/scenario/nodes/lifecycle/parameters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of parameters to be
applied to the node workflow.
  """
  __slots__ = ('_path_helper', '_extmethods', '__input','__value',)

  _yang_name = 'parameters'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__input = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd', 'scenario', 'nodes', 'lifecycle', 'parameters']

  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /outputs/vnfbd/scenario/nodes/lifecycle/parameters/input (string)

    YANG Description: The name of the parameter.
    """
    return self.__input
      
  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /outputs/vnfbd/scenario/nodes/lifecycle/parameters/input (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.

    YANG Description: The name of the parameter.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /outputs/vnfbd/scenario/nodes/lifecycle/parameters/value (string)

    YANG Description: The value of the parameter
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /outputs/vnfbd/scenario/nodes/lifecycle/parameters/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: The value of the parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  input = __builtin__.property(_get_input, _set_input)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('input', input), ('value', value), ])


class yc_lifecycle_vnf_br__outputs_vnfbd_scenario_nodes_lifecycle(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd/scenario/nodes/lifecycle. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The life cycle workflows to be
applied to this node.
  """
  __slots__ = ('_path_helper', '_extmethods', '__workflow','__name','__parameters','__implementation',)

  _yang_name = 'lifecycle'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__workflow = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'create': {}, 'configure': {}, 'start': {}, 'stop': {}, 'delete': {}, 'custom': {}},), is_leaf=True, yang_name="workflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='workflows', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__parameters = YANGDynClass(base=YANGListType("input",yc_parameters_vnf_br__outputs_vnfbd_scenario_nodes_lifecycle_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    self.__implementation = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="implementation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd', 'scenario', 'nodes', 'lifecycle']

  def _get_workflow(self):
    """
    Getter method for workflow, mapped from YANG variable /outputs/vnfbd/scenario/nodes/lifecycle/workflow (workflows)

    YANG Description: The type of the Workflow.
    """
    return self.__workflow
      
  def _set_workflow(self, v, load=False):
    """
    Setter method for workflow, mapped from YANG variable /outputs/vnfbd/scenario/nodes/lifecycle/workflow (workflows)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_workflow is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_workflow() directly.

    YANG Description: The type of the Workflow.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'create': {}, 'configure': {}, 'start': {}, 'stop': {}, 'delete': {}, 'custom': {}},), is_leaf=True, yang_name="workflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='workflows', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """workflow must be of a type compatible with workflows""",
          'defined-type': "vnf-br:workflows",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'create': {}, 'configure': {}, 'start': {}, 'stop': {}, 'delete': {}, 'custom': {}},), is_leaf=True, yang_name="workflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='workflows', is_config=True)""",
        })

    self.__workflow = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_workflow(self):
    self.__workflow = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'create': {}, 'configure': {}, 'start': {}, 'stop': {}, 'delete': {}, 'custom': {}},), is_leaf=True, yang_name="workflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='workflows', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /outputs/vnfbd/scenario/nodes/lifecycle/name (string)

    YANG Description: The workflow name.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /outputs/vnfbd/scenario/nodes/lifecycle/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The workflow name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_parameters(self):
    """
    Getter method for parameters, mapped from YANG variable /outputs/vnfbd/scenario/nodes/lifecycle/parameters (list)

    YANG Description: The list of parameters to be
applied to the node workflow.
    """
    return self.__parameters
      
  def _set_parameters(self, v, load=False):
    """
    Setter method for parameters, mapped from YANG variable /outputs/vnfbd/scenario/nodes/lifecycle/parameters (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameters() directly.

    YANG Description: The list of parameters to be
applied to the node workflow.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("input",yc_parameters_vnf_br__outputs_vnfbd_scenario_nodes_lifecycle_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameters must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("input",yc_parameters_vnf_br__outputs_vnfbd_scenario_nodes_lifecycle_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__parameters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameters(self):
    self.__parameters = YANGDynClass(base=YANGListType("input",yc_parameters_vnf_br__outputs_vnfbd_scenario_nodes_lifecycle_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)


  def _get_implementation(self):
    """
    Getter method for implementation, mapped from YANG variable /outputs/vnfbd/scenario/nodes/lifecycle/implementation (string)

    YANG Description: The workflow implementation.
    """
    return self.__implementation
      
  def _set_implementation(self, v, load=False):
    """
    Setter method for implementation, mapped from YANG variable /outputs/vnfbd/scenario/nodes/lifecycle/implementation (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_implementation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_implementation() directly.

    YANG Description: The workflow implementation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="implementation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """implementation must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="implementation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__implementation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_implementation(self):
    self.__implementation = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="implementation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  workflow = __builtin__.property(_get_workflow, _set_workflow)
  name = __builtin__.property(_get_name, _set_name)
  parameters = __builtin__.property(_get_parameters, _set_parameters)
  implementation = __builtin__.property(_get_implementation, _set_implementation)


  _pyangbind_elements = OrderedDict([('workflow', workflow), ('name', name), ('parameters', parameters), ('implementation', implementation), ])


class yc_nodes_vnf_br__outputs_vnfbd_scenario_nodes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd/scenario/nodes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of nodes that must be
instantiated in a scenario in order to enable
a benchmarking Test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__type','__image','__format','__role','__resources','__connection_points','__relationships','__lifecycle',)

  _yang_name = 'nodes'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__image = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__format = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__role = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__resources = YANGDynClass(base=yc_resources_vnf_br__outputs_vnfbd_scenario_nodes_resources, is_container='container', yang_name="resources", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    self.__connection_points = YANGDynClass(base=YANGListType("id",yc_connection_points_vnf_br__outputs_vnfbd_scenario_nodes_connection_points, yang_name="connection_points", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    self.__relationships = YANGDynClass(base=YANGListType("name",yc_relationships_vnf_br__outputs_vnfbd_scenario_nodes_relationships, yang_name="relationships", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="relationships", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    self.__lifecycle = YANGDynClass(base=YANGListType("workflow",yc_lifecycle_vnf_br__outputs_vnfbd_scenario_nodes_lifecycle, yang_name="lifecycle", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='workflow', extensions=None), is_container='list', yang_name="lifecycle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd', 'scenario', 'nodes']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /outputs/vnfbd/scenario/nodes/id (string)

    YANG Description: The unique identifier of a node
in a scenario.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /outputs/vnfbd/scenario/nodes/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The unique identifier of a node
in a scenario.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /outputs/vnfbd/scenario/nodes/type (string)

    YANG Description: The type of a node.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /outputs/vnfbd/scenario/nodes/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of a node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_image(self):
    """
    Getter method for image, mapped from YANG variable /outputs/vnfbd/scenario/nodes/image (string)

    YANG Description: The name of the image to be used to instantiate
a node.
    """
    return self.__image
      
  def _set_image(self, v, load=False):
    """
    Setter method for image, mapped from YANG variable /outputs/vnfbd/scenario/nodes/image (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_image is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_image() directly.

    YANG Description: The name of the image to be used to instantiate
a node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """image must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__image = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_image(self):
    self.__image = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_format(self):
    """
    Getter method for format, mapped from YANG variable /outputs/vnfbd/scenario/nodes/format (string)

    YANG Description: The node format (e.g., container, process, VM).
    """
    return self.__format
      
  def _set_format(self, v, load=False):
    """
    Setter method for format, mapped from YANG variable /outputs/vnfbd/scenario/nodes/format (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_format is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_format() directly.

    YANG Description: The node format (e.g., container, process, VM).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """format must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__format = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_format(self):
    self.__format = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_role(self):
    """
    Getter method for role, mapped from YANG variable /outputs/vnfbd/scenario/nodes/role (string)

    YANG Description: The role of the node in the Test scenario.
The role must be one of: manager, agent, monitor, sut.
    """
    return self.__role
      
  def _set_role(self, v, load=False):
    """
    Setter method for role, mapped from YANG variable /outputs/vnfbd/scenario/nodes/role (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_role is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_role() directly.

    YANG Description: The role of the node in the Test scenario.
The role must be one of: manager, agent, monitor, sut.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """role must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__role = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_role(self):
    self.__role = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_resources(self):
    """
    Getter method for resources, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources (container)

    YANG Description: The set of resources that must be allocated
for a node in a benchmarking Test.
    """
    return self.__resources
      
  def _set_resources(self, v, load=False):
    """
    Setter method for resources, mapped from YANG variable /outputs/vnfbd/scenario/nodes/resources (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_resources is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_resources() directly.

    YANG Description: The set of resources that must be allocated
for a node in a benchmarking Test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_resources_vnf_br__outputs_vnfbd_scenario_nodes_resources, is_container='container', yang_name="resources", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """resources must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_resources_vnf_br__outputs_vnfbd_scenario_nodes_resources, is_container='container', yang_name="resources", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__resources = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_resources(self):
    self.__resources = YANGDynClass(base=yc_resources_vnf_br__outputs_vnfbd_scenario_nodes_resources, is_container='container', yang_name="resources", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)


  def _get_connection_points(self):
    """
    Getter method for connection_points, mapped from YANG variable /outputs/vnfbd/scenario/nodes/connection_points (list)

    YANG Description: The list of connection points of a node.
    """
    return self.__connection_points
      
  def _set_connection_points(self, v, load=False):
    """
    Setter method for connection_points, mapped from YANG variable /outputs/vnfbd/scenario/nodes/connection_points (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_points is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_points() directly.

    YANG Description: The list of connection points of a node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_connection_points_vnf_br__outputs_vnfbd_scenario_nodes_connection_points, yang_name="connection_points", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_points must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_connection_points_vnf_br__outputs_vnfbd_scenario_nodes_connection_points, yang_name="connection_points", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__connection_points = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_points(self):
    self.__connection_points = YANGDynClass(base=YANGListType("id",yc_connection_points_vnf_br__outputs_vnfbd_scenario_nodes_connection_points, yang_name="connection_points", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)


  def _get_relationships(self):
    """
    Getter method for relationships, mapped from YANG variable /outputs/vnfbd/scenario/nodes/relationships (list)

    YANG Description: Relationship of a node with the other
scenario components.
    """
    return self.__relationships
      
  def _set_relationships(self, v, load=False):
    """
    Setter method for relationships, mapped from YANG variable /outputs/vnfbd/scenario/nodes/relationships (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relationships is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relationships() directly.

    YANG Description: Relationship of a node with the other
scenario components.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_relationships_vnf_br__outputs_vnfbd_scenario_nodes_relationships, yang_name="relationships", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="relationships", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """relationships must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_relationships_vnf_br__outputs_vnfbd_scenario_nodes_relationships, yang_name="relationships", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="relationships", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__relationships = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_relationships(self):
    self.__relationships = YANGDynClass(base=YANGListType("name",yc_relationships_vnf_br__outputs_vnfbd_scenario_nodes_relationships, yang_name="relationships", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="relationships", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)


  def _get_lifecycle(self):
    """
    Getter method for lifecycle, mapped from YANG variable /outputs/vnfbd/scenario/nodes/lifecycle (list)

    YANG Description: The life cycle workflows to be
applied to this node.
    """
    return self.__lifecycle
      
  def _set_lifecycle(self, v, load=False):
    """
    Setter method for lifecycle, mapped from YANG variable /outputs/vnfbd/scenario/nodes/lifecycle (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lifecycle is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lifecycle() directly.

    YANG Description: The life cycle workflows to be
applied to this node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("workflow",yc_lifecycle_vnf_br__outputs_vnfbd_scenario_nodes_lifecycle, yang_name="lifecycle", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='workflow', extensions=None), is_container='list', yang_name="lifecycle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lifecycle must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("workflow",yc_lifecycle_vnf_br__outputs_vnfbd_scenario_nodes_lifecycle, yang_name="lifecycle", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='workflow', extensions=None), is_container='list', yang_name="lifecycle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__lifecycle = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lifecycle(self):
    self.__lifecycle = YANGDynClass(base=YANGListType("workflow",yc_lifecycle_vnf_br__outputs_vnfbd_scenario_nodes_lifecycle, yang_name="lifecycle", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='workflow', extensions=None), is_container='list', yang_name="lifecycle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  type = __builtin__.property(_get_type, _set_type)
  image = __builtin__.property(_get_image, _set_image)
  format = __builtin__.property(_get_format, _set_format)
  role = __builtin__.property(_get_role, _set_role)
  resources = __builtin__.property(_get_resources, _set_resources)
  connection_points = __builtin__.property(_get_connection_points, _set_connection_points)
  relationships = __builtin__.property(_get_relationships, _set_relationships)
  lifecycle = __builtin__.property(_get_lifecycle, _set_lifecycle)


  _pyangbind_elements = OrderedDict([('id', id), ('type', type), ('image', image), ('format', format), ('role', role), ('resources', resources), ('connection_points', connection_points), ('relationships', relationships), ('lifecycle', lifecycle), ])


class yc_links_vnf_br__outputs_vnfbd_scenario_links(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd/scenario/links. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of links among nodes that must be
instantiated in a scenario in order to enable
a benchmarking Test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__type','__network','__connection_points',)

  _yang_name = 'links'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__network = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__connection_points = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd', 'scenario', 'links']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /outputs/vnfbd/scenario/links/id (string)

    YANG Description: The link unique identifier.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /outputs/vnfbd/scenario/links/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The link unique identifier.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /outputs/vnfbd/scenario/links/name (string)

    YANG Description: The name of the link.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /outputs/vnfbd/scenario/links/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the link.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /outputs/vnfbd/scenario/links/type (string)

    YANG Description: The type of the link.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /outputs/vnfbd/scenario/links/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of the link.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_network(self):
    """
    Getter method for network, mapped from YANG variable /outputs/vnfbd/scenario/links/network (string)

    YANG Description: The network the link belongs to.
    """
    return self.__network
      
  def _set_network(self, v, load=False):
    """
    Setter method for network, mapped from YANG variable /outputs/vnfbd/scenario/links/network (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network() directly.

    YANG Description: The network the link belongs to.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network(self):
    self.__network = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_connection_points(self):
    """
    Getter method for connection_points, mapped from YANG variable /outputs/vnfbd/scenario/links/connection_points (leafref)

    YANG Description: Reference to the connection points of nodes
the link is adjacent.
    """
    return self.__connection_points
      
  def _set_connection_points(self, v, load=False):
    """
    Setter method for connection_points, mapped from YANG variable /outputs/vnfbd/scenario/links/connection_points (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_points is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_points() directly.

    YANG Description: Reference to the connection points of nodes
the link is adjacent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_points must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='leafref', is_config=True)""",
        })

    self.__connection_points = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_points(self):
    self.__connection_points = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="connection_points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='leafref', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  network = __builtin__.property(_get_network, _set_network)
  connection_points = __builtin__.property(_get_connection_points, _set_connection_points)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('type', type), ('network', network), ('connection_points', connection_points), ])


class yc_policies_vnf_br__outputs_vnfbd_scenario_policies(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd/scenario/policies. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Definition of policies to be
utilized on the instantiation of the scenario.
A policy is defined by a name, it type,
the targets (nodes and/or links) to which it must be applied to,
and the proper action that realizes the policy.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__type','__targets','__action',)

  _yang_name = 'policies'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__targets = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__action = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd', 'scenario', 'policies']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /outputs/vnfbd/scenario/policies/name (string)

    YANG Description: The name of the policy.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /outputs/vnfbd/scenario/policies/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the policy.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /outputs/vnfbd/scenario/policies/type (string)

    YANG Description: The type of the policy
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /outputs/vnfbd/scenario/policies/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of the policy
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_targets(self):
    """
    Getter method for targets, mapped from YANG variable /outputs/vnfbd/scenario/policies/targets (string)

    YANG Description: The targets of the policy.
Uuid of nodes and/or links separated by comma.
    """
    return self.__targets
      
  def _set_targets(self, v, load=False):
    """
    Setter method for targets, mapped from YANG variable /outputs/vnfbd/scenario/policies/targets (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_targets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_targets() directly.

    YANG Description: The targets of the policy.
Uuid of nodes and/or links separated by comma.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """targets must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__targets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_targets(self):
    self.__targets = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_action(self):
    """
    Getter method for action, mapped from YANG variable /outputs/vnfbd/scenario/policies/action (string)

    YANG Description: The action of the policy
    """
    return self.__action
      
  def _set_action(self, v, load=False):
    """
    Setter method for action, mapped from YANG variable /outputs/vnfbd/scenario/policies/action (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_action() directly.

    YANG Description: The action of the policy
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """action must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_action(self):
    self.__action = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  targets = __builtin__.property(_get_targets, _set_targets)
  action = __builtin__.property(_get_action, _set_action)


  _pyangbind_elements = OrderedDict([('name', name), ('type', type), ('targets', targets), ('action', action), ])


class yc_scenario_vnf_br__outputs_vnfbd_scenario(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd/scenario. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Scenarios defined by this VNF-BD.
A scenario contains all information needed to describe
the deployment of all involved functional components
mandatory for the execution of a benchmarking Test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__nodes','__links','__policies',)

  _yang_name = 'scenario'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__nodes = YANGDynClass(base=YANGListType("id",yc_nodes_vnf_br__outputs_vnfbd_scenario_nodes, yang_name="nodes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    self.__links = YANGDynClass(base=YANGListType("id",yc_links_vnf_br__outputs_vnfbd_scenario_links, yang_name="links", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    self.__policies = YANGDynClass(base=YANGListType("name",yc_policies_vnf_br__outputs_vnfbd_scenario_policies, yang_name="policies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd', 'scenario']

  def _get_nodes(self):
    """
    Getter method for nodes, mapped from YANG variable /outputs/vnfbd/scenario/nodes (list)

    YANG Description: The list of nodes that must be
instantiated in a scenario in order to enable
a benchmarking Test.
    """
    return self.__nodes
      
  def _set_nodes(self, v, load=False):
    """
    Setter method for nodes, mapped from YANG variable /outputs/vnfbd/scenario/nodes (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nodes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nodes() directly.

    YANG Description: The list of nodes that must be
instantiated in a scenario in order to enable
a benchmarking Test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_nodes_vnf_br__outputs_vnfbd_scenario_nodes, yang_name="nodes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nodes must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_nodes_vnf_br__outputs_vnfbd_scenario_nodes, yang_name="nodes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__nodes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nodes(self):
    self.__nodes = YANGDynClass(base=YANGListType("id",yc_nodes_vnf_br__outputs_vnfbd_scenario_nodes, yang_name="nodes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)


  def _get_links(self):
    """
    Getter method for links, mapped from YANG variable /outputs/vnfbd/scenario/links (list)

    YANG Description: The list of links among nodes that must be
instantiated in a scenario in order to enable
a benchmarking Test.
    """
    return self.__links
      
  def _set_links(self, v, load=False):
    """
    Setter method for links, mapped from YANG variable /outputs/vnfbd/scenario/links (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_links is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_links() directly.

    YANG Description: The list of links among nodes that must be
instantiated in a scenario in order to enable
a benchmarking Test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_links_vnf_br__outputs_vnfbd_scenario_links, yang_name="links", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """links must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_links_vnf_br__outputs_vnfbd_scenario_links, yang_name="links", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__links = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_links(self):
    self.__links = YANGDynClass(base=YANGListType("id",yc_links_vnf_br__outputs_vnfbd_scenario_links, yang_name="links", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)


  def _get_policies(self):
    """
    Getter method for policies, mapped from YANG variable /outputs/vnfbd/scenario/policies (list)

    YANG Description: Definition of policies to be
utilized on the instantiation of the scenario.
A policy is defined by a name, it type,
the targets (nodes and/or links) to which it must be applied to,
and the proper action that realizes the policy.
    """
    return self.__policies
      
  def _set_policies(self, v, load=False):
    """
    Setter method for policies, mapped from YANG variable /outputs/vnfbd/scenario/policies (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policies is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policies() directly.

    YANG Description: Definition of policies to be
utilized on the instantiation of the scenario.
A policy is defined by a name, it type,
the targets (nodes and/or links) to which it must be applied to,
and the proper action that realizes the policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_policies_vnf_br__outputs_vnfbd_scenario_policies, yang_name="policies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policies must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_policies_vnf_br__outputs_vnfbd_scenario_policies, yang_name="policies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__policies = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policies(self):
    self.__policies = YANGDynClass(base=YANGListType("name",yc_policies_vnf_br__outputs_vnfbd_scenario_policies, yang_name="policies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

  nodes = __builtin__.property(_get_nodes, _set_nodes)
  links = __builtin__.property(_get_links, _set_links)
  policies = __builtin__.property(_get_policies, _set_policies)


  _pyangbind_elements = OrderedDict([('nodes', nodes), ('links', links), ('policies', policies), ])


class yc_parameters_vnf_br__outputs_vnfbd_proceedings_agents_probers_parameters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd/proceedings/agents/probers/parameters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters for the execution
of the tool. Each tool detains the proper set of running
parameters that must be utilized to realize a benchmarking
test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__input','__value',)

  _yang_name = 'parameters'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__input = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd', 'proceedings', 'agents', 'probers', 'parameters']

  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/parameters/input (string)

    YANG Description: The input key of a parameter
    """
    return self.__input
      
  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/parameters/input (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.

    YANG Description: The input key of a parameter
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/parameters/value (string)

    YANG Description: The value of a parameter
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/parameters/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: The value of a parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  input = __builtin__.property(_get_input, _set_input)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('input', input), ('value', value), ])


class yc_sched_vnf_br__outputs_vnfbd_proceedings_agents_probers_sched(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd/proceedings/agents/probers/sched. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The scheduling parameters of a tool.
Each Agent/Monitor must utilize the scheduling parameters
to perform the execution of its tools (probers/listeners)
accordingly.
  """
  __slots__ = ('_path_helper', '_extmethods', '__from_','__until','__duration','__interval','__repeat',)

  _yang_name = 'sched'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__from_ = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__until = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="until", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__duration = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__repeat = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd', 'proceedings', 'agents', 'probers', 'sched']

  def _get_from_(self):
    """
    Getter method for from_, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/sched/from (uint32)

    YANG Description: The initial time (in seconds)
of the execution of the tool.
    """
    return self.__from_
      
  def _set_from_(self, v, load=False):
    """
    Setter method for from_, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/sched/from (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_from_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_from_() directly.

    YANG Description: The initial time (in seconds)
of the execution of the tool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """from_ must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__from_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_from_(self):
    self.__from_ = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_until(self):
    """
    Getter method for until, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/sched/until (uint32)

    YANG Description: The final/maximum time (in seconds)
of the execution of the tool summed all its instances
repeat, duration and interval parameters.
    """
    return self.__until
      
  def _set_until(self, v, load=False):
    """
    Setter method for until, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/sched/until (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_until is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_until() directly.

    YANG Description: The final/maximum time (in seconds)
of the execution of the tool summed all its instances
repeat, duration and interval parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="until", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """until must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="until", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__until = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_until(self):
    self.__until = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="until", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_duration(self):
    """
    Getter method for duration, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/sched/duration (uint32)

    YANG Description: The total duration (in seconds) of the execution
of each instance of the tool.
    """
    return self.__duration
      
  def _set_duration(self, v, load=False):
    """
    Setter method for duration, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/sched/duration (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_duration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_duration() directly.

    YANG Description: The total duration (in seconds) of the execution
of each instance of the tool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """duration must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__duration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_duration(self):
    self.__duration = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/sched/interval (uint32)

    YANG Description: The interval (in seconds) to be awaited
among each one of the instances of the execution of the tool.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/sched/interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: The interval (in seconds) to be awaited
among each one of the instances of the execution of the tool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_repeat(self):
    """
    Getter method for repeat, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/sched/repeat (uint32)

    YANG Description: The number of times the tool must be executed.
    """
    return self.__repeat
      
  def _set_repeat(self, v, load=False):
    """
    Setter method for repeat, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/sched/repeat (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_repeat is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_repeat() directly.

    YANG Description: The number of times the tool must be executed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """repeat must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__repeat = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_repeat(self):
    self.__repeat = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)

  from_ = __builtin__.property(_get_from_, _set_from_)
  until = __builtin__.property(_get_until, _set_until)
  duration = __builtin__.property(_get_duration, _set_duration)
  interval = __builtin__.property(_get_interval, _set_interval)
  repeat = __builtin__.property(_get_repeat, _set_repeat)


  _pyangbind_elements = OrderedDict([('from_', from_), ('until', until), ('duration', duration), ('interval', interval), ('repeat', repeat), ])


class yc_probers_vnf_br__outputs_vnfbd_proceedings_agents_probers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd/proceedings/agents/probers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines a list of the Prober(s)
that must be used in a benchmarking test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__instances','__name','__parameters','__sched',)

  _yang_name = 'probers'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__instances = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__parameters = YANGDynClass(base=YANGListType("input",yc_parameters_vnf_br__outputs_vnfbd_proceedings_agents_probers_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    self.__sched = YANGDynClass(base=yc_sched_vnf_br__outputs_vnfbd_proceedings_agents_probers_sched, is_container='container', yang_name="sched", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd', 'proceedings', 'agents', 'probers']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/id (uint32)

    YANG Description: The unique identifier of a tool.
This information specifies how a tool can be
identified in a list of probers/listeners of an
Agent/Monitor.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The unique identifier of a tool.
This information specifies how a tool can be
identified in a list of probers/listeners of an
Agent/Monitor.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_instances(self):
    """
    Getter method for instances, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/instances (uint32)

    YANG Description: The number of the tool instances that
must be executed in parallel.
    """
    return self.__instances
      
  def _set_instances(self, v, load=False):
    """
    Setter method for instances, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/instances (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instances() directly.

    YANG Description: The number of the tool instances that
must be executed in parallel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instances must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__instances = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instances(self):
    self.__instances = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/name (string)

    YANG Description: The name of a tool.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of a tool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_parameters(self):
    """
    Getter method for parameters, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/parameters (list)

    YANG Description: List of parameters for the execution
of the tool. Each tool detains the proper set of running
parameters that must be utilized to realize a benchmarking
test.
    """
    return self.__parameters
      
  def _set_parameters(self, v, load=False):
    """
    Setter method for parameters, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/parameters (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameters() directly.

    YANG Description: List of parameters for the execution
of the tool. Each tool detains the proper set of running
parameters that must be utilized to realize a benchmarking
test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("input",yc_parameters_vnf_br__outputs_vnfbd_proceedings_agents_probers_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameters must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("input",yc_parameters_vnf_br__outputs_vnfbd_proceedings_agents_probers_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__parameters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameters(self):
    self.__parameters = YANGDynClass(base=YANGListType("input",yc_parameters_vnf_br__outputs_vnfbd_proceedings_agents_probers_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)


  def _get_sched(self):
    """
    Getter method for sched, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/sched (container)

    YANG Description: The scheduling parameters of a tool.
Each Agent/Monitor must utilize the scheduling parameters
to perform the execution of its tools (probers/listeners)
accordingly.
    """
    return self.__sched
      
  def _set_sched(self, v, load=False):
    """
    Setter method for sched, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers/sched (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sched is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sched() directly.

    YANG Description: The scheduling parameters of a tool.
Each Agent/Monitor must utilize the scheduling parameters
to perform the execution of its tools (probers/listeners)
accordingly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_sched_vnf_br__outputs_vnfbd_proceedings_agents_probers_sched, is_container='container', yang_name="sched", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sched must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_sched_vnf_br__outputs_vnfbd_proceedings_agents_probers_sched, is_container='container', yang_name="sched", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__sched = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sched(self):
    self.__sched = YANGDynClass(base=yc_sched_vnf_br__outputs_vnfbd_proceedings_agents_probers_sched, is_container='container', yang_name="sched", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  instances = __builtin__.property(_get_instances, _set_instances)
  name = __builtin__.property(_get_name, _set_name)
  parameters = __builtin__.property(_get_parameters, _set_parameters)
  sched = __builtin__.property(_get_sched, _set_sched)


  _pyangbind_elements = OrderedDict([('id', id), ('instances', instances), ('name', name), ('parameters', parameters), ('sched', sched), ])


class yc_agents_vnf_br__outputs_vnfbd_proceedings_agents(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd/proceedings/agents. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines a list containing the
Agent(s) needed for a VNF-BD test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__uuid','__name','__probers',)

  _yang_name = 'agents'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__probers = YANGDynClass(base=YANGListType("id",yc_probers_vnf_br__outputs_vnfbd_proceedings_agents_probers, yang_name="probers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="probers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd', 'proceedings', 'agents']

  def _get_uuid(self):
    """
    Getter method for uuid, mapped from YANG variable /outputs/vnfbd/proceedings/agents/uuid (string)

    YANG Description: A unique identifier
    """
    return self.__uuid
      
  def _set_uuid(self, v, load=False):
    """
    Setter method for uuid, mapped from YANG variable /outputs/vnfbd/proceedings/agents/uuid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uuid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uuid() directly.

    YANG Description: A unique identifier
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uuid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__uuid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uuid(self):
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /outputs/vnfbd/proceedings/agents/name (string)

    YANG Description: The name of component
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /outputs/vnfbd/proceedings/agents/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of component
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_probers(self):
    """
    Getter method for probers, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers (list)

    YANG Description: Defines a list of the Prober(s)
that must be used in a benchmarking test.
    """
    return self.__probers
      
  def _set_probers(self, v, load=False):
    """
    Setter method for probers, mapped from YANG variable /outputs/vnfbd/proceedings/agents/probers (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_probers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_probers() directly.

    YANG Description: Defines a list of the Prober(s)
that must be used in a benchmarking test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_probers_vnf_br__outputs_vnfbd_proceedings_agents_probers, yang_name="probers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="probers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """probers must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_probers_vnf_br__outputs_vnfbd_proceedings_agents_probers, yang_name="probers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="probers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__probers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_probers(self):
    self.__probers = YANGDynClass(base=YANGListType("id",yc_probers_vnf_br__outputs_vnfbd_proceedings_agents_probers, yang_name="probers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="probers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

  uuid = __builtin__.property(_get_uuid, _set_uuid)
  name = __builtin__.property(_get_name, _set_name)
  probers = __builtin__.property(_get_probers, _set_probers)


  _pyangbind_elements = OrderedDict([('uuid', uuid), ('name', name), ('probers', probers), ])


class yc_parameters_vnf_br__outputs_vnfbd_proceedings_monitors_listeners_parameters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd/proceedings/monitors/listeners/parameters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters for the execution
of the tool. Each tool detains the proper set of running
parameters that must be utilized to realize a benchmarking
test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__input','__value',)

  _yang_name = 'parameters'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__input = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd', 'proceedings', 'monitors', 'listeners', 'parameters']

  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/parameters/input (string)

    YANG Description: The input key of a parameter
    """
    return self.__input
      
  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/parameters/input (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.

    YANG Description: The input key of a parameter
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/parameters/value (string)

    YANG Description: The value of a parameter
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/parameters/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: The value of a parameter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  input = __builtin__.property(_get_input, _set_input)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('input', input), ('value', value), ])


class yc_sched_vnf_br__outputs_vnfbd_proceedings_monitors_listeners_sched(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd/proceedings/monitors/listeners/sched. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The scheduling parameters of a tool.
Each Agent/Monitor must utilize the scheduling parameters
to perform the execution of its tools (probers/listeners)
accordingly.
  """
  __slots__ = ('_path_helper', '_extmethods', '__from_','__until','__duration','__interval','__repeat',)

  _yang_name = 'sched'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__from_ = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__until = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="until", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__duration = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__repeat = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd', 'proceedings', 'monitors', 'listeners', 'sched']

  def _get_from_(self):
    """
    Getter method for from_, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/sched/from (uint32)

    YANG Description: The initial time (in seconds)
of the execution of the tool.
    """
    return self.__from_
      
  def _set_from_(self, v, load=False):
    """
    Setter method for from_, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/sched/from (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_from_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_from_() directly.

    YANG Description: The initial time (in seconds)
of the execution of the tool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """from_ must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__from_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_from_(self):
    self.__from_ = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="from", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_until(self):
    """
    Getter method for until, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/sched/until (uint32)

    YANG Description: The final/maximum time (in seconds)
of the execution of the tool summed all its instances
repeat, duration and interval parameters.
    """
    return self.__until
      
  def _set_until(self, v, load=False):
    """
    Setter method for until, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/sched/until (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_until is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_until() directly.

    YANG Description: The final/maximum time (in seconds)
of the execution of the tool summed all its instances
repeat, duration and interval parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="until", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """until must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="until", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__until = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_until(self):
    self.__until = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="until", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_duration(self):
    """
    Getter method for duration, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/sched/duration (uint32)

    YANG Description: The total duration (in seconds) of the execution
of each instance of the tool.
    """
    return self.__duration
      
  def _set_duration(self, v, load=False):
    """
    Setter method for duration, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/sched/duration (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_duration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_duration() directly.

    YANG Description: The total duration (in seconds) of the execution
of each instance of the tool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """duration must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__duration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_duration(self):
    self.__duration = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/sched/interval (uint32)

    YANG Description: The interval (in seconds) to be awaited
among each one of the instances of the execution of the tool.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/sched/interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: The interval (in seconds) to be awaited
among each one of the instances of the execution of the tool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_repeat(self):
    """
    Getter method for repeat, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/sched/repeat (uint32)

    YANG Description: The number of times the tool must be executed.
    """
    return self.__repeat
      
  def _set_repeat(self, v, load=False):
    """
    Setter method for repeat, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/sched/repeat (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_repeat is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_repeat() directly.

    YANG Description: The number of times the tool must be executed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """repeat must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__repeat = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_repeat(self):
    self.__repeat = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)

  from_ = __builtin__.property(_get_from_, _set_from_)
  until = __builtin__.property(_get_until, _set_until)
  duration = __builtin__.property(_get_duration, _set_duration)
  interval = __builtin__.property(_get_interval, _set_interval)
  repeat = __builtin__.property(_get_repeat, _set_repeat)


  _pyangbind_elements = OrderedDict([('from_', from_), ('until', until), ('duration', duration), ('interval', interval), ('repeat', repeat), ])


class yc_listeners_vnf_br__outputs_vnfbd_proceedings_monitors_listeners(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd/proceedings/monitors/listeners. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines a list of the Listeners(s)
that must used in a benchmarking test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__instances','__name','__parameters','__sched',)

  _yang_name = 'listeners'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__instances = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__parameters = YANGDynClass(base=YANGListType("input",yc_parameters_vnf_br__outputs_vnfbd_proceedings_monitors_listeners_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    self.__sched = YANGDynClass(base=yc_sched_vnf_br__outputs_vnfbd_proceedings_monitors_listeners_sched, is_container='container', yang_name="sched", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd', 'proceedings', 'monitors', 'listeners']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/id (uint32)

    YANG Description: The unique identifier of a tool.
This information specifies how a tool can be
identified in a list of probers/listeners of an
Agent/Monitor.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The unique identifier of a tool.
This information specifies how a tool can be
identified in a list of probers/listeners of an
Agent/Monitor.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_instances(self):
    """
    Getter method for instances, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/instances (uint32)

    YANG Description: The number of the tool instances that
must be executed in parallel.
    """
    return self.__instances
      
  def _set_instances(self, v, load=False):
    """
    Setter method for instances, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/instances (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instances() directly.

    YANG Description: The number of the tool instances that
must be executed in parallel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instances must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__instances = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instances(self):
    self.__instances = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/name (string)

    YANG Description: The name of a tool.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of a tool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_parameters(self):
    """
    Getter method for parameters, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/parameters (list)

    YANG Description: List of parameters for the execution
of the tool. Each tool detains the proper set of running
parameters that must be utilized to realize a benchmarking
test.
    """
    return self.__parameters
      
  def _set_parameters(self, v, load=False):
    """
    Setter method for parameters, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/parameters (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameters() directly.

    YANG Description: List of parameters for the execution
of the tool. Each tool detains the proper set of running
parameters that must be utilized to realize a benchmarking
test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("input",yc_parameters_vnf_br__outputs_vnfbd_proceedings_monitors_listeners_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameters must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("input",yc_parameters_vnf_br__outputs_vnfbd_proceedings_monitors_listeners_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__parameters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameters(self):
    self.__parameters = YANGDynClass(base=YANGListType("input",yc_parameters_vnf_br__outputs_vnfbd_proceedings_monitors_listeners_parameters, yang_name="parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='input', extensions=None), is_container='list', yang_name="parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)


  def _get_sched(self):
    """
    Getter method for sched, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/sched (container)

    YANG Description: The scheduling parameters of a tool.
Each Agent/Monitor must utilize the scheduling parameters
to perform the execution of its tools (probers/listeners)
accordingly.
    """
    return self.__sched
      
  def _set_sched(self, v, load=False):
    """
    Setter method for sched, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners/sched (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sched is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sched() directly.

    YANG Description: The scheduling parameters of a tool.
Each Agent/Monitor must utilize the scheduling parameters
to perform the execution of its tools (probers/listeners)
accordingly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_sched_vnf_br__outputs_vnfbd_proceedings_monitors_listeners_sched, is_container='container', yang_name="sched", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sched must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_sched_vnf_br__outputs_vnfbd_proceedings_monitors_listeners_sched, is_container='container', yang_name="sched", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__sched = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sched(self):
    self.__sched = YANGDynClass(base=yc_sched_vnf_br__outputs_vnfbd_proceedings_monitors_listeners_sched, is_container='container', yang_name="sched", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  instances = __builtin__.property(_get_instances, _set_instances)
  name = __builtin__.property(_get_name, _set_name)
  parameters = __builtin__.property(_get_parameters, _set_parameters)
  sched = __builtin__.property(_get_sched, _set_sched)


  _pyangbind_elements = OrderedDict([('id', id), ('instances', instances), ('name', name), ('parameters', parameters), ('sched', sched), ])


class yc_monitors_vnf_br__outputs_vnfbd_proceedings_monitors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd/proceedings/monitors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines a list containing the
Monitor(s) needed for a VNF-BD test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__uuid','__name','__listeners',)

  _yang_name = 'monitors'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__listeners = YANGDynClass(base=YANGListType("id",yc_listeners_vnf_br__outputs_vnfbd_proceedings_monitors_listeners, yang_name="listeners", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="listeners", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd', 'proceedings', 'monitors']

  def _get_uuid(self):
    """
    Getter method for uuid, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/uuid (string)

    YANG Description: A unique identifier
    """
    return self.__uuid
      
  def _set_uuid(self, v, load=False):
    """
    Setter method for uuid, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/uuid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uuid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uuid() directly.

    YANG Description: A unique identifier
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uuid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__uuid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uuid(self):
    self.__uuid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uuid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/name (string)

    YANG Description: The name of component
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of component
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_listeners(self):
    """
    Getter method for listeners, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners (list)

    YANG Description: Defines a list of the Listeners(s)
that must used in a benchmarking test.
    """
    return self.__listeners
      
  def _set_listeners(self, v, load=False):
    """
    Setter method for listeners, mapped from YANG variable /outputs/vnfbd/proceedings/monitors/listeners (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_listeners is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_listeners() directly.

    YANG Description: Defines a list of the Listeners(s)
that must used in a benchmarking test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_listeners_vnf_br__outputs_vnfbd_proceedings_monitors_listeners, yang_name="listeners", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="listeners", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """listeners must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_listeners_vnf_br__outputs_vnfbd_proceedings_monitors_listeners, yang_name="listeners", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="listeners", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__listeners = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_listeners(self):
    self.__listeners = YANGDynClass(base=YANGListType("id",yc_listeners_vnf_br__outputs_vnfbd_proceedings_monitors_listeners, yang_name="listeners", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="listeners", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

  uuid = __builtin__.property(_get_uuid, _set_uuid)
  name = __builtin__.property(_get_name, _set_name)
  listeners = __builtin__.property(_get_listeners, _set_listeners)


  _pyangbind_elements = OrderedDict([('uuid', uuid), ('name', name), ('listeners', listeners), ])


class yc_proceedings_vnf_br__outputs_vnfbd_proceedings(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd/proceedings. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Proceedings of VNF-BD.
The proceedings are utilized by the Manager component
to execute a benchmarking Test. It consists of
agent(s)/monitor(s) settings, detailing their prober(s)/listener(s)
specification and running parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__agents','__monitors',)

  _yang_name = 'proceedings'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__agents = YANGDynClass(base=YANGListType("uuid",yc_agents_vnf_br__outputs_vnfbd_proceedings_agents, yang_name="agents", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="agents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    self.__monitors = YANGDynClass(base=YANGListType("uuid",yc_monitors_vnf_br__outputs_vnfbd_proceedings_monitors, yang_name="monitors", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd', 'proceedings']

  def _get_agents(self):
    """
    Getter method for agents, mapped from YANG variable /outputs/vnfbd/proceedings/agents (list)

    YANG Description: Defines a list containing the
Agent(s) needed for a VNF-BD test.
    """
    return self.__agents
      
  def _set_agents(self, v, load=False):
    """
    Setter method for agents, mapped from YANG variable /outputs/vnfbd/proceedings/agents (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_agents is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_agents() directly.

    YANG Description: Defines a list containing the
Agent(s) needed for a VNF-BD test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("uuid",yc_agents_vnf_br__outputs_vnfbd_proceedings_agents, yang_name="agents", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="agents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """agents must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("uuid",yc_agents_vnf_br__outputs_vnfbd_proceedings_agents, yang_name="agents", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="agents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__agents = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_agents(self):
    self.__agents = YANGDynClass(base=YANGListType("uuid",yc_agents_vnf_br__outputs_vnfbd_proceedings_agents, yang_name="agents", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="agents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)


  def _get_monitors(self):
    """
    Getter method for monitors, mapped from YANG variable /outputs/vnfbd/proceedings/monitors (list)

    YANG Description: Defines a list containing the
Monitor(s) needed for a VNF-BD test.
    """
    return self.__monitors
      
  def _set_monitors(self, v, load=False):
    """
    Setter method for monitors, mapped from YANG variable /outputs/vnfbd/proceedings/monitors (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitors() directly.

    YANG Description: Defines a list containing the
Monitor(s) needed for a VNF-BD test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("uuid",yc_monitors_vnf_br__outputs_vnfbd_proceedings_monitors, yang_name="monitors", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """monitors must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("uuid",yc_monitors_vnf_br__outputs_vnfbd_proceedings_monitors, yang_name="monitors", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__monitors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_monitors(self):
    self.__monitors = YANGDynClass(base=YANGListType("uuid",yc_monitors_vnf_br__outputs_vnfbd_proceedings_monitors, yang_name="monitors", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='uuid', extensions=None), is_container='list', yang_name="monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

  agents = __builtin__.property(_get_agents, _set_agents)
  monitors = __builtin__.property(_get_monitors, _set_monitors)


  _pyangbind_elements = OrderedDict([('agents', agents), ('monitors', monitors), ])


class yc_vnfbd_vnf_br__outputs_vnfbd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfbd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The VNF-BD that was executed
to generate a output.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__version','__description','__timestamp','__experiments','__scenario','__proceedings',)

  _yang_name = 'vnfbd'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__timestamp = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__experiments = YANGDynClass(base=yc_experiments_vnf_br__outputs_vnfbd_experiments, is_container='container', yang_name="experiments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    self.__scenario = YANGDynClass(base=yc_scenario_vnf_br__outputs_vnfbd_scenario, is_container='container', yang_name="scenario", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    self.__proceedings = YANGDynClass(base=yc_proceedings_vnf_br__outputs_vnfbd_proceedings, is_container='container', yang_name="proceedings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfbd']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /outputs/vnfbd/id (string)

    YANG Description: Unique identifier of the VNF-BD.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /outputs/vnfbd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of the VNF-BD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /outputs/vnfbd/name (string)

    YANG Description: Name of the VNF-BD.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /outputs/vnfbd/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the VNF-BD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /outputs/vnfbd/version (string)

    YANG Description: Version of the VNF-BD.
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /outputs/vnfbd/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Version of the VNF-BD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /outputs/vnfbd/description (string)

    YANG Description: Description of the VNF-BD
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /outputs/vnfbd/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the VNF-BD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_timestamp(self):
    """
    Getter method for timestamp, mapped from YANG variable /outputs/vnfbd/timestamp (string)

    YANG Description: Time (date, hour, minute, second)
when the VNF-BD was created.
    """
    return self.__timestamp
      
  def _set_timestamp(self, v, load=False):
    """
    Setter method for timestamp, mapped from YANG variable /outputs/vnfbd/timestamp (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timestamp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timestamp() directly.

    YANG Description: Time (date, hour, minute, second)
when the VNF-BD was created.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timestamp must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__timestamp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timestamp(self):
    self.__timestamp = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_experiments(self):
    """
    Getter method for experiments, mapped from YANG variable /outputs/vnfbd/experiments (container)

    YANG Description: Defines the number of trials and tests
the VNF-BD must execute.
    """
    return self.__experiments
      
  def _set_experiments(self, v, load=False):
    """
    Setter method for experiments, mapped from YANG variable /outputs/vnfbd/experiments (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_experiments is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_experiments() directly.

    YANG Description: Defines the number of trials and tests
the VNF-BD must execute.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_experiments_vnf_br__outputs_vnfbd_experiments, is_container='container', yang_name="experiments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """experiments must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_experiments_vnf_br__outputs_vnfbd_experiments, is_container='container', yang_name="experiments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__experiments = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_experiments(self):
    self.__experiments = YANGDynClass(base=yc_experiments_vnf_br__outputs_vnfbd_experiments, is_container='container', yang_name="experiments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)


  def _get_scenario(self):
    """
    Getter method for scenario, mapped from YANG variable /outputs/vnfbd/scenario (container)

    YANG Description: Scenarios defined by this VNF-BD.
A scenario contains all information needed to describe
the deployment of all involved functional components
mandatory for the execution of a benchmarking Test.
    """
    return self.__scenario
      
  def _set_scenario(self, v, load=False):
    """
    Setter method for scenario, mapped from YANG variable /outputs/vnfbd/scenario (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scenario is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scenario() directly.

    YANG Description: Scenarios defined by this VNF-BD.
A scenario contains all information needed to describe
the deployment of all involved functional components
mandatory for the execution of a benchmarking Test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_scenario_vnf_br__outputs_vnfbd_scenario, is_container='container', yang_name="scenario", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scenario must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_scenario_vnf_br__outputs_vnfbd_scenario, is_container='container', yang_name="scenario", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__scenario = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scenario(self):
    self.__scenario = YANGDynClass(base=yc_scenario_vnf_br__outputs_vnfbd_scenario, is_container='container', yang_name="scenario", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)


  def _get_proceedings(self):
    """
    Getter method for proceedings, mapped from YANG variable /outputs/vnfbd/proceedings (container)

    YANG Description: Proceedings of VNF-BD.
The proceedings are utilized by the Manager component
to execute a benchmarking Test. It consists of
agent(s)/monitor(s) settings, detailing their prober(s)/listener(s)
specification and running parameters.
    """
    return self.__proceedings
      
  def _set_proceedings(self, v, load=False):
    """
    Setter method for proceedings, mapped from YANG variable /outputs/vnfbd/proceedings (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proceedings is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proceedings() directly.

    YANG Description: Proceedings of VNF-BD.
The proceedings are utilized by the Manager component
to execute a benchmarking Test. It consists of
agent(s)/monitor(s) settings, detailing their prober(s)/listener(s)
specification and running parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_proceedings_vnf_br__outputs_vnfbd_proceedings, is_container='container', yang_name="proceedings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """proceedings must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_proceedings_vnf_br__outputs_vnfbd_proceedings, is_container='container', yang_name="proceedings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__proceedings = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_proceedings(self):
    self.__proceedings = YANGDynClass(base=yc_proceedings_vnf_br__outputs_vnfbd_proceedings, is_container='container', yang_name="proceedings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  version = __builtin__.property(_get_version, _set_version)
  description = __builtin__.property(_get_description, _set_description)
  timestamp = __builtin__.property(_get_timestamp, _set_timestamp)
  experiments = __builtin__.property(_get_experiments, _set_experiments)
  scenario = __builtin__.property(_get_scenario, _set_scenario)
  proceedings = __builtin__.property(_get_proceedings, _set_proceedings)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('version', version), ('description', description), ('timestamp', timestamp), ('experiments', experiments), ('scenario', scenario), ('proceedings', proceedings), ])


class yc_origin_vnf_br__outputs_vnfpp_reports_snapshots_origin(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfpp/reports/snapshots/origin. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The detailed origin of
the snapshot.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__role','__host',)

  _yang_name = 'origin'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__role = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__host = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfpp', 'reports', 'snapshots', 'origin']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /outputs/vnfpp/reports/snapshots/origin/id (string)

    YANG Description: The unique identifier of the
component of the origin of the snapshot,
i.e., the agent or monitor unique identifier.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /outputs/vnfpp/reports/snapshots/origin/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The unique identifier of the
component of the origin of the snapshot,
i.e., the agent or monitor unique identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_role(self):
    """
    Getter method for role, mapped from YANG variable /outputs/vnfpp/reports/snapshots/origin/role (string)

    YANG Description: The role of the component,
origin of the snapshop, i.e.,
one of agent or monitor.
    """
    return self.__role
      
  def _set_role(self, v, load=False):
    """
    Setter method for role, mapped from YANG variable /outputs/vnfpp/reports/snapshots/origin/role (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_role is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_role() directly.

    YANG Description: The role of the component,
origin of the snapshop, i.e.,
one of agent or monitor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """role must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__role = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_role(self):
    self.__role = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_host(self):
    """
    Getter method for host, mapped from YANG variable /outputs/vnfpp/reports/snapshots/origin/host (string)

    YANG Description: The hostname where the
source of the snapshot was placed.
    """
    return self.__host
      
  def _set_host(self, v, load=False):
    """
    Setter method for host, mapped from YANG variable /outputs/vnfpp/reports/snapshots/origin/host (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_host is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_host() directly.

    YANG Description: The hostname where the
source of the snapshot was placed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """host must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__host = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_host(self):
    self.__host = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  role = __builtin__.property(_get_role, _set_role)
  host = __builtin__.property(_get_host, _set_host)


  _pyangbind_elements = OrderedDict([('id', id), ('role', role), ('host', host), ])


class yc_source_vnf_br__outputs_vnfpp_reports_snapshots_evaluations_source(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfpp/reports/snapshots/evaluations/source. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The details regarding the
source of the evaluation.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__type','__version','__call',)

  _yang_name = 'source'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__call = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="call", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfpp', 'reports', 'snapshots', 'evaluations', 'source']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/source/id (string)

    YANG Description: The unique identifier of the source
of the evaluation,
i.e., the prober/listener unique identifier.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/source/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The unique identifier of the source
of the evaluation,
i.e., the prober/listener unique identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/source/name (string)

    YANG Description: The name of the source of the evaluation,
i.e., the prober/listener name.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/source/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the source of the evaluation,
i.e., the prober/listener name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/source/type (string)

    YANG Description: The type of the source of the evaluation,
i.e., one of prober or listener,  that was used to obtain
it.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/source/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of the source of the evaluation,
i.e., one of prober or listener,  that was used to obtain
it.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/source/version (string)

    YANG Description: The version of the tool interfacing
the prober/listener that was used to obtain
the evaluation.
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/source/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The version of the tool interfacing
the prober/listener that was used to obtain
the evaluation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_call(self):
    """
    Getter method for call, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/source/call (string)

    YANG Description: The full call of the tool realized by
the source of the evaluation that performed
the acquisiton of the metrics.
    """
    return self.__call
      
  def _set_call(self, v, load=False):
    """
    Setter method for call, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/source/call (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_call is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_call() directly.

    YANG Description: The full call of the tool realized by
the source of the evaluation that performed
the acquisiton of the metrics.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="call", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """call must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="call", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__call = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_call(self):
    self.__call = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="call", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  version = __builtin__.property(_get_version, _set_version)
  call = __builtin__.property(_get_call, _set_call)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('type', type), ('version', version), ('call', call), ])


class yc_timestamp_vnf_br__outputs_vnfpp_reports_snapshots_evaluations_timestamp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfpp/reports/snapshots/evaluations/timestamp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Timestamps of the procedures
that realized the extraction of the evaluation.
  """
  __slots__ = ('_path_helper', '_extmethods', '__start','__stop',)

  _yang_name = 'timestamp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__start = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__stop = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="stop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfpp', 'reports', 'snapshots', 'evaluations', 'timestamp']

  def _get_start(self):
    """
    Getter method for start, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/timestamp/start (string)

    YANG Description: Time (date, hour, minute, second)
when the evaluation started
    """
    return self.__start
      
  def _set_start(self, v, load=False):
    """
    Setter method for start, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/timestamp/start (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start() directly.

    YANG Description: Time (date, hour, minute, second)
when the evaluation started
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__start = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start(self):
    self.__start = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_stop(self):
    """
    Getter method for stop, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/timestamp/stop (string)

    YANG Description: Time (date, hour, minute, second)
when the evaluation stopped
    """
    return self.__stop
      
  def _set_stop(self, v, load=False):
    """
    Setter method for stop, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/timestamp/stop (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stop() directly.

    YANG Description: Time (date, hour, minute, second)
when the evaluation stopped
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="stop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stop must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="stop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__stop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stop(self):
    self.__stop = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="stop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  start = __builtin__.property(_get_start, _set_start)
  stop = __builtin__.property(_get_stop, _set_stop)


  _pyangbind_elements = OrderedDict([('start', start), ('stop', stop), ])


class yc_series_vnf_br__outputs_vnfpp_reports_snapshots_evaluations_metrics_series(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfpp/reports/snapshots/evaluations/metrics/series. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list of key/values,
e.g., a timeseries.
  """
  __slots__ = ('_path_helper', '_extmethods', '__key','__value',)

  _yang_name = 'series'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, choice=('value', 'series'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=('value', 'series'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfpp', 'reports', 'snapshots', 'evaluations', 'metrics', 'series']

  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/metrics/series/key (string)

    YANG Description: Tuple key.
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/metrics/series/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Tuple key.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, choice=('value', 'series'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, choice=('value', 'series'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, choice=('value', 'series'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/metrics/series/value (string)

    YANG Description: Tuple value.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/metrics/series/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Tuple value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=('value', 'series'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=('value', 'series'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=('value', 'series'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  key = __builtin__.property(_get_key, _set_key)
  value = __builtin__.property(_get_value, _set_value)

  __choices__ = {'value': {'series': ['key', 'value']}}
  _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_metrics_vnf_br__outputs_vnfpp_reports_snapshots_evaluations_metrics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfpp/reports/snapshots/evaluations/metrics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of metrics obtained
from a single evaluation.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__unit','__type','__scalar','__vector','__series',)

  _yang_name = 'metrics'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__unit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__scalar = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="scalar", parent=self, choice=('value', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__vector = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="vector", parent=self, choice=('value', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__series = YANGDynClass(base=YANGListType("key",yc_series_vnf_br__outputs_vnfpp_reports_snapshots_evaluations_metrics_series, yang_name="series", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None, choice=False), is_container='list', yang_name="series", parent=self, choice=('value', 'series'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfpp', 'reports', 'snapshots', 'evaluations', 'metrics']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/metrics/name (string)

    YANG Description: The metric name
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/metrics/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The metric name
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_unit(self):
    """
    Getter method for unit, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/metrics/unit (string)

    YANG Description: The unit of the metric value(s).
    """
    return self.__unit
      
  def _set_unit(self, v, load=False):
    """
    Setter method for unit, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/metrics/unit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unit() directly.

    YANG Description: The unit of the metric value(s).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__unit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unit(self):
    self.__unit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/metrics/type (string)

    YANG Description: The data type encoded in the value.
It must refer to a known variable type, i.e.,
string, float, uint, etc.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/metrics/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The data type encoded in the value.
It must refer to a known variable type, i.e.,
string, float, uint, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_scalar(self):
    """
    Getter method for scalar, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/metrics/scalar (string)

    YANG Description: A single scalar value.
    """
    return self.__scalar
      
  def _set_scalar(self, v, load=False):
    """
    Setter method for scalar, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/metrics/scalar (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scalar is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scalar() directly.

    YANG Description: A single scalar value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="scalar", parent=self, choice=('value', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """scalar must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="scalar", parent=self, choice=('value', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__scalar = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_scalar(self):
    self.__scalar = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="scalar", parent=self, choice=('value', 'scalar'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_vector(self):
    """
    Getter method for vector, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/metrics/vector (string)

    YANG Description: A list of scalar values
    """
    return self.__vector
      
  def _set_vector(self, v, load=False):
    """
    Setter method for vector, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/metrics/vector (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vector() directly.

    YANG Description: A list of scalar values
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="vector", parent=self, choice=('value', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vector must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="vector", parent=self, choice=('value', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__vector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vector(self):
    self.__vector = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="vector", parent=self, choice=('value', 'vector'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_series(self):
    """
    Getter method for series, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/metrics/series (list)

    YANG Description: A list of key/values,
e.g., a timeseries.
    """
    return self.__series
      
  def _set_series(self, v, load=False):
    """
    Setter method for series, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/metrics/series (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_series is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_series() directly.

    YANG Description: A list of key/values,
e.g., a timeseries.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("key",yc_series_vnf_br__outputs_vnfpp_reports_snapshots_evaluations_metrics_series, yang_name="series", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None, choice=False), is_container='list', yang_name="series", parent=self, choice=('value', 'series'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """series must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("key",yc_series_vnf_br__outputs_vnfpp_reports_snapshots_evaluations_metrics_series, yang_name="series", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None, choice=False), is_container='list', yang_name="series", parent=self, choice=('value', 'series'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__series = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_series(self):
    self.__series = YANGDynClass(base=YANGListType("key",yc_series_vnf_br__outputs_vnfpp_reports_snapshots_evaluations_metrics_series, yang_name="series", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None, choice=False), is_container='list', yang_name="series", parent=self, choice=('value', 'series'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  unit = __builtin__.property(_get_unit, _set_unit)
  type = __builtin__.property(_get_type, _set_type)
  scalar = __builtin__.property(_get_scalar, _set_scalar)
  vector = __builtin__.property(_get_vector, _set_vector)
  series = __builtin__.property(_get_series, _set_series)

  __choices__ = {'value': {'scalar': ['scalar'], 'vector': ['vector'], 'series': ['series']}}
  _pyangbind_elements = OrderedDict([('name', name), ('unit', unit), ('type', type), ('scalar', scalar), ('vector', vector), ('series', series), ])


class yc_evaluations_vnf_br__outputs_vnfpp_reports_snapshots_evaluations(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfpp/reports/snapshots/evaluations. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of evaluations
contained in a single snapshot Test.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__instance','__repeat','__source','__timestamp','__metrics','__error',)

  _yang_name = 'evaluations'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__instance = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__repeat = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__source = YANGDynClass(base=yc_source_vnf_br__outputs_vnfpp_reports_snapshots_evaluations_source, is_container='container', yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    self.__timestamp = YANGDynClass(base=yc_timestamp_vnf_br__outputs_vnfpp_reports_snapshots_evaluations_timestamp, is_container='container', yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    self.__metrics = YANGDynClass(base=YANGListType("name",yc_metrics_vnf_br__outputs_vnfpp_reports_snapshots_evaluations_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    self.__error = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfpp', 'reports', 'snapshots', 'evaluations']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/id (string)

    YANG Description: The evaluation
unique identifier.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The evaluation
unique identifier.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_instance(self):
    """
    Getter method for instance, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/instance (uint32)

    YANG Description: The unique identifier of the
parallel instance of the prober/listener that
was executed and created the evaluation.
    """
    return self.__instance
      
  def _set_instance(self, v, load=False):
    """
    Setter method for instance, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/instance (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instance() directly.

    YANG Description: The unique identifier of the
parallel instance of the prober/listener that
was executed and created the evaluation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instance must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instance(self):
    self.__instance = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_repeat(self):
    """
    Getter method for repeat, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/repeat (uint32)

    YANG Description: The unique identifier of the
prober/listener repeatition instance
was executed and created the evaluation.
    """
    return self.__repeat
      
  def _set_repeat(self, v, load=False):
    """
    Setter method for repeat, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/repeat (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_repeat is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_repeat() directly.

    YANG Description: The unique identifier of the
prober/listener repeatition instance
was executed and created the evaluation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """repeat must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__repeat = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_repeat(self):
    self.__repeat = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_source(self):
    """
    Getter method for source, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/source (container)

    YANG Description: The details regarding the
source of the evaluation.
    """
    return self.__source
      
  def _set_source(self, v, load=False):
    """
    Setter method for source, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/source (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source() directly.

    YANG Description: The details regarding the
source of the evaluation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_source_vnf_br__outputs_vnfpp_reports_snapshots_evaluations_source, is_container='container', yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_source_vnf_br__outputs_vnfpp_reports_snapshots_evaluations_source, is_container='container', yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source(self):
    self.__source = YANGDynClass(base=yc_source_vnf_br__outputs_vnfpp_reports_snapshots_evaluations_source, is_container='container', yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)


  def _get_timestamp(self):
    """
    Getter method for timestamp, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/timestamp (container)

    YANG Description: Timestamps of the procedures
that realized the extraction of the evaluation.
    """
    return self.__timestamp
      
  def _set_timestamp(self, v, load=False):
    """
    Setter method for timestamp, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/timestamp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timestamp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timestamp() directly.

    YANG Description: Timestamps of the procedures
that realized the extraction of the evaluation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_timestamp_vnf_br__outputs_vnfpp_reports_snapshots_evaluations_timestamp, is_container='container', yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timestamp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_timestamp_vnf_br__outputs_vnfpp_reports_snapshots_evaluations_timestamp, is_container='container', yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__timestamp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timestamp(self):
    self.__timestamp = YANGDynClass(base=yc_timestamp_vnf_br__outputs_vnfpp_reports_snapshots_evaluations_timestamp, is_container='container', yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)


  def _get_metrics(self):
    """
    Getter method for metrics, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/metrics (list)

    YANG Description: List of metrics obtained
from a single evaluation.
    """
    return self.__metrics
      
  def _set_metrics(self, v, load=False):
    """
    Setter method for metrics, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/metrics (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metrics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metrics() directly.

    YANG Description: List of metrics obtained
from a single evaluation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_metrics_vnf_br__outputs_vnfpp_reports_snapshots_evaluations_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metrics must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_metrics_vnf_br__outputs_vnfpp_reports_snapshots_evaluations_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__metrics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metrics(self):
    self.__metrics = YANGDynClass(base=YANGListType("name",yc_metrics_vnf_br__outputs_vnfpp_reports_snapshots_evaluations_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)


  def _get_error(self):
    """
    Getter method for error, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/error (string)

    YANG Description: Error, if existent,
when obtaining evaluation.
    """
    return self.__error
      
  def _set_error(self, v, load=False):
    """
    Setter method for error, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations/error (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error() directly.

    YANG Description: Error, if existent,
when obtaining evaluation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__error = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error(self):
    self.__error = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  instance = __builtin__.property(_get_instance, _set_instance)
  repeat = __builtin__.property(_get_repeat, _set_repeat)
  source = __builtin__.property(_get_source, _set_source)
  timestamp = __builtin__.property(_get_timestamp, _set_timestamp)
  metrics = __builtin__.property(_get_metrics, _set_metrics)
  error = __builtin__.property(_get_error, _set_error)


  _pyangbind_elements = OrderedDict([('id', id), ('instance', instance), ('repeat', repeat), ('source', source), ('timestamp', timestamp), ('metrics', metrics), ('error', error), ])


class yc_snapshots_vnf_br__outputs_vnfpp_reports_snapshots(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfpp/reports/snapshots. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of snapshots contained
in a single report.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__trial','__origin','__evaluations','__timestamp','__error',)

  _yang_name = 'snapshots'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__trial = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="trial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__origin = YANGDynClass(base=yc_origin_vnf_br__outputs_vnfpp_reports_snapshots_origin, is_container='container', yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    self.__evaluations = YANGDynClass(base=YANGListType("id",yc_evaluations_vnf_br__outputs_vnfpp_reports_snapshots_evaluations, yang_name="evaluations", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="evaluations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    self.__timestamp = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__error = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfpp', 'reports', 'snapshots']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /outputs/vnfpp/reports/snapshots/id (string)

    YANG Description: The snapshot
unique identifier.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /outputs/vnfpp/reports/snapshots/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The snapshot
unique identifier.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_trial(self):
    """
    Getter method for trial, mapped from YANG variable /outputs/vnfpp/reports/snapshots/trial (uint32)

    YANG Description: The identifier of the trial
when the snapshot was obtained.
    """
    return self.__trial
      
  def _set_trial(self, v, load=False):
    """
    Setter method for trial, mapped from YANG variable /outputs/vnfpp/reports/snapshots/trial (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trial is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trial() directly.

    YANG Description: The identifier of the trial
when the snapshot was obtained.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="trial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trial must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="trial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__trial = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trial(self):
    self.__trial = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="trial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /outputs/vnfpp/reports/snapshots/origin (container)

    YANG Description: The detailed origin of
the snapshot.
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /outputs/vnfpp/reports/snapshots/origin (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: The detailed origin of
the snapshot.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_origin_vnf_br__outputs_vnfpp_reports_snapshots_origin, is_container='container', yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_origin_vnf_br__outputs_vnfpp_reports_snapshots_origin, is_container='container', yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=yc_origin_vnf_br__outputs_vnfpp_reports_snapshots_origin, is_container='container', yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)


  def _get_evaluations(self):
    """
    Getter method for evaluations, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations (list)

    YANG Description: The list of evaluations
contained in a single snapshot Test.
    """
    return self.__evaluations
      
  def _set_evaluations(self, v, load=False):
    """
    Setter method for evaluations, mapped from YANG variable /outputs/vnfpp/reports/snapshots/evaluations (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_evaluations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_evaluations() directly.

    YANG Description: The list of evaluations
contained in a single snapshot Test.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_evaluations_vnf_br__outputs_vnfpp_reports_snapshots_evaluations, yang_name="evaluations", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="evaluations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """evaluations must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_evaluations_vnf_br__outputs_vnfpp_reports_snapshots_evaluations, yang_name="evaluations", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="evaluations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__evaluations = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_evaluations(self):
    self.__evaluations = YANGDynClass(base=YANGListType("id",yc_evaluations_vnf_br__outputs_vnfpp_reports_snapshots_evaluations, yang_name="evaluations", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="evaluations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)


  def _get_timestamp(self):
    """
    Getter method for timestamp, mapped from YANG variable /outputs/vnfpp/reports/snapshots/timestamp (string)

    YANG Description: Time (date, hour, minute, second)
when the snapshot was created.
    """
    return self.__timestamp
      
  def _set_timestamp(self, v, load=False):
    """
    Setter method for timestamp, mapped from YANG variable /outputs/vnfpp/reports/snapshots/timestamp (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timestamp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timestamp() directly.

    YANG Description: Time (date, hour, minute, second)
when the snapshot was created.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timestamp must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__timestamp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timestamp(self):
    self.__timestamp = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_error(self):
    """
    Getter method for error, mapped from YANG variable /outputs/vnfpp/reports/snapshots/error (string)

    YANG Description: Error, if existent,
when obtaining the snapshot.
    """
    return self.__error
      
  def _set_error(self, v, load=False):
    """
    Setter method for error, mapped from YANG variable /outputs/vnfpp/reports/snapshots/error (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error() directly.

    YANG Description: Error, if existent,
when obtaining the snapshot.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__error = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error(self):
    self.__error = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  trial = __builtin__.property(_get_trial, _set_trial)
  origin = __builtin__.property(_get_origin, _set_origin)
  evaluations = __builtin__.property(_get_evaluations, _set_evaluations)
  timestamp = __builtin__.property(_get_timestamp, _set_timestamp)
  error = __builtin__.property(_get_error, _set_error)


  _pyangbind_elements = OrderedDict([('id', id), ('trial', trial), ('origin', origin), ('evaluations', evaluations), ('timestamp', timestamp), ('error', error), ])


class yc_reports_vnf_br__outputs_vnfpp_reports(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfpp/reports. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of the reports of a VNF-PP.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__test','__snapshots','__timestamp','__error',)

  _yang_name = 'reports'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__test = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="test", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    self.__snapshots = YANGDynClass(base=YANGListType("id",yc_snapshots_vnf_br__outputs_vnfpp_reports_snapshots, yang_name="snapshots", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="snapshots", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    self.__timestamp = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__error = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfpp', 'reports']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /outputs/vnfpp/reports/id (string)

    YANG Description: The report unique identifier.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /outputs/vnfpp/reports/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The report unique identifier.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_test(self):
    """
    Getter method for test, mapped from YANG variable /outputs/vnfpp/reports/test (uint32)

    YANG Description: The identifier of the Test
when the snapshots were obtained.
    """
    return self.__test
      
  def _set_test(self, v, load=False):
    """
    Setter method for test, mapped from YANG variable /outputs/vnfpp/reports/test (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_test is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_test() directly.

    YANG Description: The identifier of the Test
when the snapshots were obtained.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="test", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """test must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="test", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)""",
        })

    self.__test = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_test(self):
    self.__test = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="test", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='uint32', is_config=True)


  def _get_snapshots(self):
    """
    Getter method for snapshots, mapped from YANG variable /outputs/vnfpp/reports/snapshots (list)

    YANG Description: List of snapshots contained
in a single report.
    """
    return self.__snapshots
      
  def _set_snapshots(self, v, load=False):
    """
    Setter method for snapshots, mapped from YANG variable /outputs/vnfpp/reports/snapshots (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_snapshots is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_snapshots() directly.

    YANG Description: List of snapshots contained
in a single report.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_snapshots_vnf_br__outputs_vnfpp_reports_snapshots, yang_name="snapshots", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="snapshots", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """snapshots must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_snapshots_vnf_br__outputs_vnfpp_reports_snapshots, yang_name="snapshots", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="snapshots", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__snapshots = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_snapshots(self):
    self.__snapshots = YANGDynClass(base=YANGListType("id",yc_snapshots_vnf_br__outputs_vnfpp_reports_snapshots, yang_name="snapshots", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="snapshots", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)


  def _get_timestamp(self):
    """
    Getter method for timestamp, mapped from YANG variable /outputs/vnfpp/reports/timestamp (string)

    YANG Description: Time (date, hour, minute, second)
when the report was created.
    """
    return self.__timestamp
      
  def _set_timestamp(self, v, load=False):
    """
    Setter method for timestamp, mapped from YANG variable /outputs/vnfpp/reports/timestamp (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timestamp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timestamp() directly.

    YANG Description: Time (date, hour, minute, second)
when the report was created.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timestamp must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__timestamp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timestamp(self):
    self.__timestamp = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_error(self):
    """
    Getter method for error, mapped from YANG variable /outputs/vnfpp/reports/error (string)

    YANG Description: Error, if existent,
when obtaining the report.
    """
    return self.__error
      
  def _set_error(self, v, load=False):
    """
    Setter method for error, mapped from YANG variable /outputs/vnfpp/reports/error (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error() directly.

    YANG Description: Error, if existent,
when obtaining the report.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__error = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error(self):
    self.__error = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  test = __builtin__.property(_get_test, _set_test)
  snapshots = __builtin__.property(_get_snapshots, _set_snapshots)
  timestamp = __builtin__.property(_get_timestamp, _set_timestamp)
  error = __builtin__.property(_get_error, _set_error)


  _pyangbind_elements = OrderedDict([('id', id), ('test', test), ('snapshots', snapshots), ('timestamp', timestamp), ('error', error), ])


class yc_vnfpp_vnf_br__outputs_vnfpp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs/vnfpp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The output VNF-PP of the
execution of a VNF-BD.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__version','__description','__timestamp','__reports',)

  _yang_name = 'vnfpp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__timestamp = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__reports = YANGDynClass(base=YANGListType("id",yc_reports_vnf_br__outputs_vnfpp_reports, yang_name="reports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="reports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs', 'vnfpp']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /outputs/vnfpp/id (string)

    YANG Description: Unique identifier of the VNF-PP.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /outputs/vnfpp/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of the VNF-PP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /outputs/vnfpp/name (string)

    YANG Description: Name of the VNF-PP.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /outputs/vnfpp/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the VNF-PP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /outputs/vnfpp/version (string)

    YANG Description: Version of the VNF-PP.
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /outputs/vnfpp/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Version of the VNF-PP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /outputs/vnfpp/description (string)

    YANG Description: Description of the VNF-PP
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /outputs/vnfpp/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the VNF-PP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_timestamp(self):
    """
    Getter method for timestamp, mapped from YANG variable /outputs/vnfpp/timestamp (string)

    YANG Description: Time (date, hour, minute, second)
when the VNF-PP was created.
    """
    return self.__timestamp
      
  def _set_timestamp(self, v, load=False):
    """
    Setter method for timestamp, mapped from YANG variable /outputs/vnfpp/timestamp (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timestamp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timestamp() directly.

    YANG Description: Time (date, hour, minute, second)
when the VNF-PP was created.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timestamp must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__timestamp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timestamp(self):
    self.__timestamp = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_reports(self):
    """
    Getter method for reports, mapped from YANG variable /outputs/vnfpp/reports (list)

    YANG Description: List of the reports of a VNF-PP.
    """
    return self.__reports
      
  def _set_reports(self, v, load=False):
    """
    Setter method for reports, mapped from YANG variable /outputs/vnfpp/reports (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reports() directly.

    YANG Description: List of the reports of a VNF-PP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_reports_vnf_br__outputs_vnfpp_reports, yang_name="reports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="reports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reports must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_reports_vnf_br__outputs_vnfpp_reports, yang_name="reports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="reports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__reports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reports(self):
    self.__reports = YANGDynClass(base=YANGListType("id",yc_reports_vnf_br__outputs_vnfpp_reports, yang_name="reports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="reports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  version = __builtin__.property(_get_version, _set_version)
  description = __builtin__.property(_get_description, _set_description)
  timestamp = __builtin__.property(_get_timestamp, _set_timestamp)
  reports = __builtin__.property(_get_reports, _set_reports)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('version', version), ('description', description), ('timestamp', timestamp), ('reports', reports), ])


class yc_outputs_vnf_br__outputs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /outputs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of outputs
of a VNF-BR.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__variables','__vnfbd','__vnfpp',)

  _yang_name = 'outputs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__variables = YANGDynClass(base=YANGListType("name",yc_variables_vnf_br__outputs_variables, yang_name="variables", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="variables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    self.__vnfbd = YANGDynClass(base=yc_vnfbd_vnf_br__outputs_vnfbd, is_container='container', yang_name="vnfbd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    self.__vnfpp = YANGDynClass(base=yc_vnfpp_vnf_br__outputs_vnfpp, is_container='container', yang_name="vnfpp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['outputs']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /outputs/id (string)

    YANG Description: The output unique identifier.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /outputs/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The output unique identifier.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_variables(self):
    """
    Getter method for variables, mapped from YANG variable /outputs/variables (list)

    YANG Description: The list of instance of varibles
from VNF-BR:inputs utilized by a VNF-BD to
generate a VNF-PP.
    """
    return self.__variables
      
  def _set_variables(self, v, load=False):
    """
    Setter method for variables, mapped from YANG variable /outputs/variables (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_variables is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_variables() directly.

    YANG Description: The list of instance of varibles
from VNF-BR:inputs utilized by a VNF-BD to
generate a VNF-PP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_variables_vnf_br__outputs_variables, yang_name="variables", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="variables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """variables must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_variables_vnf_br__outputs_variables, yang_name="variables", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="variables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__variables = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_variables(self):
    self.__variables = YANGDynClass(base=YANGListType("name",yc_variables_vnf_br__outputs_variables, yang_name="variables", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="variables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)


  def _get_vnfbd(self):
    """
    Getter method for vnfbd, mapped from YANG variable /outputs/vnfbd (container)

    YANG Description: The VNF-BD that was executed
to generate a output.
    """
    return self.__vnfbd
      
  def _set_vnfbd(self, v, load=False):
    """
    Setter method for vnfbd, mapped from YANG variable /outputs/vnfbd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfbd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfbd() directly.

    YANG Description: The VNF-BD that was executed
to generate a output.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vnfbd_vnf_br__outputs_vnfbd, is_container='container', yang_name="vnfbd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfbd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vnfbd_vnf_br__outputs_vnfbd, is_container='container', yang_name="vnfbd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__vnfbd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfbd(self):
    self.__vnfbd = YANGDynClass(base=yc_vnfbd_vnf_br__outputs_vnfbd, is_container='container', yang_name="vnfbd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)


  def _get_vnfpp(self):
    """
    Getter method for vnfpp, mapped from YANG variable /outputs/vnfpp (container)

    YANG Description: The output VNF-PP of the
execution of a VNF-BD.
    """
    return self.__vnfpp
      
  def _set_vnfpp(self, v, load=False):
    """
    Setter method for vnfpp, mapped from YANG variable /outputs/vnfpp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfpp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfpp() directly.

    YANG Description: The output VNF-PP of the
execution of a VNF-BD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vnfpp_vnf_br__outputs_vnfpp, is_container='container', yang_name="vnfpp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnfpp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vnfpp_vnf_br__outputs_vnfpp, is_container='container', yang_name="vnfpp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__vnfpp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnfpp(self):
    self.__vnfpp = YANGDynClass(base=yc_vnfpp_vnf_br__outputs_vnfpp, is_container='container', yang_name="vnfpp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  variables = __builtin__.property(_get_variables, _set_variables)
  vnfbd = __builtin__.property(_get_vnfbd, _set_vnfbd)
  vnfpp = __builtin__.property(_get_vnfpp, _set_vnfpp)


  _pyangbind_elements = OrderedDict([('id', id), ('variables', variables), ('vnfbd', vnfbd), ('vnfpp', vnfpp), ])


class yc_timestamp_vnf_br__timestamp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /timestamp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Timestamps of the procedures that
realized the realization of a VNF-BR.
  """
  __slots__ = ('_path_helper', '_extmethods', '__start','__stop',)

  _yang_name = 'timestamp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__start = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__stop = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="stop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['timestamp']

  def _get_start(self):
    """
    Getter method for start, mapped from YANG variable /timestamp/start (string)

    YANG Description: Time (date, hour, minute, second)
of when the VNF-BR realization started
    """
    return self.__start
      
  def _set_start(self, v, load=False):
    """
    Setter method for start, mapped from YANG variable /timestamp/start (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start() directly.

    YANG Description: Time (date, hour, minute, second)
of when the VNF-BR realization started
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__start = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start(self):
    self.__start = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_stop(self):
    """
    Getter method for stop, mapped from YANG variable /timestamp/stop (string)

    YANG Description: Time (date, hour, minute, second)
of when the VNF-BR realization stopped
    """
    return self.__stop
      
  def _set_stop(self, v, load=False):
    """
    Setter method for stop, mapped from YANG variable /timestamp/stop (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stop() directly.

    YANG Description: Time (date, hour, minute, second)
of when the VNF-BR realization stopped
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="stop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stop must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="stop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__stop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stop(self):
    self.__stop = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="stop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  start = __builtin__.property(_get_start, _set_start)
  stop = __builtin__.property(_get_stop, _set_stop)


  _pyangbind_elements = OrderedDict([('start', start), ('stop', stop), ])


class vnf_br(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnf-br - based on the path /vnf-br. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Yang model for a VNF Benchmark Report (VNF-BR).
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__version','__author','__description','__vnf','__environment','__inputs','__outputs','__timestamp','__error',)

  _yang_name = 'vnf-br'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    extmethods = kwargs.pop("extmethods", None)
    if extmethods is False:
      self._extmethods = False
    elif extmethods is not None and isinstance(extmethods, dict):
      self._extmethods = extmethods
    elif hasattr(self, "_parent"):
      extmethods = getattr(self._parent, "_extmethods", None)
      self._extmethods = extmethods
    else:
      self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__author = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="author", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    self.__vnf = YANGDynClass(base=yc_vnf_vnf_br__vnf, is_container='container', yang_name="vnf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    self.__environment = YANGDynClass(base=yc_environment_vnf_br__environment, is_container='container', yang_name="environment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    self.__inputs = YANGDynClass(base=yc_inputs_vnf_br__inputs, is_container='container', yang_name="inputs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    self.__outputs = YANGDynClass(base=YANGListType("id",yc_outputs_vnf_br__outputs, yang_name="outputs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="outputs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    self.__timestamp = YANGDynClass(base=yc_timestamp_vnf_br__timestamp, is_container='container', yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    self.__error = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /id (string)

    YANG Description: The unique identifier of the VNF-BR 
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The unique identifier of the VNF-BR 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /name (string)

    YANG Description: The name of the VNF-BR.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the VNF-BR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /version (string)

    YANG Description: The VNF-BR version.
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The VNF-BR version.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_author(self):
    """
    Getter method for author, mapped from YANG variable /author (string)

    YANG Description: The VNF-BR author.
    """
    return self.__author
      
  def _set_author(self, v, load=False):
    """
    Setter method for author, mapped from YANG variable /author (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_author is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_author() directly.

    YANG Description: The VNF-BR author.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="author", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """author must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="author", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__author = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_author(self):
    self.__author = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="author", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /description (string)

    YANG Description: The description of the VNF-BR.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: The description of the VNF-BR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)


  def _get_vnf(self):
    """
    Getter method for vnf, mapped from YANG variable /vnf (container)

    YANG Description: The VNF-BR target SUT VNF.
    """
    return self.__vnf
      
  def _set_vnf(self, v, load=False):
    """
    Setter method for vnf, mapped from YANG variable /vnf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf() directly.

    YANG Description: The VNF-BR target SUT VNF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vnf_vnf_br__vnf, is_container='container', yang_name="vnf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnf must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vnf_vnf_br__vnf, is_container='container', yang_name="vnf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__vnf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnf(self):
    self.__vnf = YANGDynClass(base=yc_vnf_vnf_br__vnf, is_container='container', yang_name="vnf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)


  def _get_environment(self):
    """
    Getter method for environment, mapped from YANG variable /environment (container)

    YANG Description: The environment settings of a VNF-BR.
    """
    return self.__environment
      
  def _set_environment(self, v, load=False):
    """
    Setter method for environment, mapped from YANG variable /environment (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_environment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_environment() directly.

    YANG Description: The environment settings of a VNF-BR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_environment_vnf_br__environment, is_container='container', yang_name="environment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """environment must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_environment_vnf_br__environment, is_container='container', yang_name="environment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__environment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_environment(self):
    self.__environment = YANGDynClass(base=yc_environment_vnf_br__environment, is_container='container', yang_name="environment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)


  def _get_inputs(self):
    """
    Getter method for inputs, mapped from YANG variable /inputs (container)

    YANG Description: The inputs needed to
realize a VNF-BR.
    """
    return self.__inputs
      
  def _set_inputs(self, v, load=False):
    """
    Setter method for inputs, mapped from YANG variable /inputs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inputs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inputs() directly.

    YANG Description: The inputs needed to
realize a VNF-BR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_inputs_vnf_br__inputs, is_container='container', yang_name="inputs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inputs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_inputs_vnf_br__inputs, is_container='container', yang_name="inputs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__inputs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inputs(self):
    self.__inputs = YANGDynClass(base=yc_inputs_vnf_br__inputs, is_container='container', yang_name="inputs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)


  def _get_outputs(self):
    """
    Getter method for outputs, mapped from YANG variable /outputs (list)

    YANG Description: The list of outputs
of a VNF-BR.
    """
    return self.__outputs
      
  def _set_outputs(self, v, load=False):
    """
    Setter method for outputs, mapped from YANG variable /outputs (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outputs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outputs() directly.

    YANG Description: The list of outputs
of a VNF-BR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_outputs_vnf_br__outputs, yang_name="outputs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="outputs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outputs must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_outputs_vnf_br__outputs, yang_name="outputs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="outputs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)""",
        })

    self.__outputs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outputs(self):
    self.__outputs = YANGDynClass(base=YANGListType("id",yc_outputs_vnf_br__outputs, yang_name="outputs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="outputs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='list', is_config=True)


  def _get_timestamp(self):
    """
    Getter method for timestamp, mapped from YANG variable /timestamp (container)

    YANG Description: Timestamps of the procedures that
realized the realization of a VNF-BR.
    """
    return self.__timestamp
      
  def _set_timestamp(self, v, load=False):
    """
    Setter method for timestamp, mapped from YANG variable /timestamp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timestamp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timestamp() directly.

    YANG Description: Timestamps of the procedures that
realized the realization of a VNF-BR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_timestamp_vnf_br__timestamp, is_container='container', yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timestamp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_timestamp_vnf_br__timestamp, is_container='container', yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)""",
        })

    self.__timestamp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timestamp(self):
    self.__timestamp = YANGDynClass(base=yc_timestamp_vnf_br__timestamp, is_container='container', yang_name="timestamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='container', is_config=True)


  def _get_error(self):
    """
    Getter method for error, mapped from YANG variable /error (string)

    YANG Description: The VNF-BR error,
if ocurred during its realization.
    """
    return self.__error
      
  def _set_error(self, v, load=False):
    """
    Setter method for error, mapped from YANG variable /error (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error() directly.

    YANG Description: The VNF-BR error,
if ocurred during its realization.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)""",
        })

    self.__error = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error(self):
    self.__error = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:vnf-br', defining_module='vnf-br', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  version = __builtin__.property(_get_version, _set_version)
  author = __builtin__.property(_get_author, _set_author)
  description = __builtin__.property(_get_description, _set_description)
  vnf = __builtin__.property(_get_vnf, _set_vnf)
  environment = __builtin__.property(_get_environment, _set_environment)
  inputs = __builtin__.property(_get_inputs, _set_inputs)
  outputs = __builtin__.property(_get_outputs, _set_outputs)
  timestamp = __builtin__.property(_get_timestamp, _set_timestamp)
  error = __builtin__.property(_get_error, _set_error)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('version', version), ('author', author), ('description', description), ('vnf', vnf), ('environment', environment), ('inputs', inputs), ('outputs', outputs), ('timestamp', timestamp), ('error', error), ])


